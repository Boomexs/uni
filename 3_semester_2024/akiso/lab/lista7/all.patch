diff --git a/7.1.patch b/7.1.patch
new file mode 100644
index 00000000..db9ae70b
--- /dev/null
+++ b/7.1.patch
@@ -0,0 +1,876 @@
+diff --git a/Makefile b/Makefile
+index f35a405..33a4039 100644
+--- a/Makefile
++++ b/Makefile
+@@ -171,6 +171,7 @@ mkfs: mkfs.c fs.h
+ # 4.4 - add _testsyscall to UPROGS
+ # 6.1 - add _testvm to UPROGS
+ # 6.2 - add _testvinfo to UPROGS
++# 7.1 - add _ps to UPROGS
+ 
+ UPROGS=\
+ 	_cat\
+@@ -194,6 +195,7 @@ UPROGS=\
+ 	_testvm\
+ 	_testvinfo\
+ 	_testmmap\
++	_ps\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+@@ -264,12 +266,13 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
+ # 4.6 - add testsyscall.c to EXTRA
+ # 6.1 - add testvm.c to EXTRA
+ # 6.2 - add testvinfo.c to EXTRA
++# 7.1 - add ps.c to EXTRA
+ 
+ EXTRA=\
+ 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+ 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+ 	printf.c umalloc.c expr.c hello.c testsyscall.c testvm.c testvinfo.c\
+-	testmmap.c\
++	testmmap.c ps.c\
+ 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+ 	.gdbinit.tmpl gdbutil\
+ 
+diff --git a/defs.h b/defs.h
+index b3025ed..fa9837e 100644
+--- a/defs.h
++++ b/defs.h
+@@ -10,6 +10,8 @@ struct sleeplock;
+ struct stat;
+ struct superblock;
+ 
++struct ptable; // 7.1 add ptable def
++
+ // bio.c
+ void            binit(void);
+ struct buf*     bread(uint, uint);
+@@ -120,6 +122,7 @@ void            userinit(void);
+ int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
++struct ptable*  getptable(void); // 7.1 add getptable def
+ 
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+diff --git a/proc.c b/proc.c
+index ed0b52c..e6f846b 100644
+--- a/proc.c
++++ b/proc.c
+@@ -7,7 +7,7 @@
+ #include "proc.h"
+ #include "spinlock.h"
+ 
+-struct {
++struct ptable {
+   struct spinlock lock;
+   struct proc proc[NPROC];
+ } ptable;
+@@ -20,6 +20,13 @@ extern void trapret(void);
+ 
+ static void wakeup1(void *chan);
+ 
++// 7.1 getptable
++struct ptable* getptable(void)
++{
++  return &ptable;
++}
++
++
+ void
+ pinit(void)
+ {
+diff --git a/proc.h b/proc.h
+index 1647114..f4c7e03 100644
+--- a/proc.h
++++ b/proc.h
+@@ -51,6 +51,15 @@ struct proc {
+   char name[16];               // Process name (debugging)
+ };
+ 
++// 7.1 add uproc
++struct uproc {
++    int pid;
++    int ppid;
++    int sz;
++    int state;
++    char name[16];
++};
++
+ // Process memory is laid out contiguously, low addresses first:
+ //   text
+ //   original data and bss
+diff --git a/ps.c b/ps.c
+new file mode 100644
+index 0000000..9d70931
+--- /dev/null
++++ b/ps.c
+@@ -0,0 +1,24 @@
++// 7.1 add ps.c
++#include "types.h"
++#include "stat.h"
++#include "user.h"
++
++int main(int argc, char *argv[])
++{
++    printf(1, "Process Status\n");
++
++    int np = getnumproc();
++    printf(1, "NumProc %d", np);
++
++    int max = getmaxpid();
++    printf(1, " MaxPID %d\n", max);
++
++    for (int i = 1; i <= max; i++) {
++        struct uproc p;
++        if (getprocinfo(i, &p) == 0) {
++            printf(1, "PID: %d, PPID: %d, Size: %d, State: %d, Name: %s\n", p.pid, p.ppid, p.sz, p.state, p.name);
++        }
++    }
++
++    exit();
++}
+diff --git a/syscall.c b/syscall.c
+index 0166b6f..31e6119 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -111,6 +111,10 @@ extern int sys_usedvp(void);
+ extern int sys_usedpp(void);
+ // 6.3 add an extern syscall function
+ extern int sys_mmap(void);
++// 7.1 add an extern syscall function
++extern int sys_getnumproc(void);
++extern int sys_getmaxpid(void);
++extern int sys_getprocinfo(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -142,6 +146,10 @@ static int (*syscalls[])(void) = {
+ [SYS_usedpp]  sys_usedpp,
+ // 6.3 add a mmap syscall into the syscall table
+ [SYS_mmap]    sys_mmap,
++// 7.1 add a syscall into the syscall table
++[SYS_getnumproc] sys_getnumproc,
++[SYS_getmaxpid] sys_getmaxpid,
++[SYS_getprocinfo] sys_getprocinfo,
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index d670a06..6525bb6 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -30,4 +30,9 @@
+ #define SYS_usedpp 25
+ 
+ // 6.3 add a syscall
+-#define SYS_mmap 26
+\ No newline at end of file
++#define SYS_mmap 26
++
++// 7.1 add a syscall
++#define SYS_getnumproc 27
++#define SYS_getmaxpid 28
++#define SYS_getprocinfo 29
+\ No newline at end of file
+diff --git a/sysfile.c b/sysfile.c
+index bc7e201..822ccfe 100644
+--- a/sysfile.c
++++ b/sysfile.c
+@@ -25,13 +25,13 @@ argfd(int n, int *pfd, struct file **pf)
+   int fd;
+   struct file *f;
+ 
+-  if(argint(n, &fd) < 0)
++  if (argint(n, &fd) < 0)
+     return -1;
+-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
++  if (fd < 0 || fd >= NOFILE || (f = myproc()->ofile[fd]) == 0)
+     return -1;
+-  if(pfd)
++  if (pfd)
+     *pfd = fd;
+-  if(pf)
++  if (pf)
+     *pf = f;
+   return 0;
+ }
+@@ -44,8 +44,10 @@ fdalloc(struct file *f)
+   int fd;
+   struct proc *curproc = myproc();
+ 
+-  for(fd = 0; fd < NOFILE; fd++){
+-    if(curproc->ofile[fd] == 0){
++  for (fd = 0; fd < NOFILE; fd++)
++  {
++    if (curproc->ofile[fd] == 0)
++    {
+       curproc->ofile[fd] = f;
+       return fd;
+     }
+@@ -53,86 +55,82 @@ fdalloc(struct file *f)
+   return -1;
+ }
+ 
+-int
+-sys_dup(void)
++int sys_dup(void)
+ {
+   struct file *f;
+   int fd;
+ 
+-  if(argfd(0, 0, &f) < 0)
++  if (argfd(0, 0, &f) < 0)
+     return -1;
+-  if((fd=fdalloc(f)) < 0)
++  if ((fd = fdalloc(f)) < 0)
+     return -1;
+   filedup(f);
+   return fd;
+ }
+ 
+-int
+-sys_read(void)
++int sys_read(void)
+ {
+   struct file *f;
+   int n;
+   char *p;
+ 
+-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
++  if (argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+     return -1;
+   return fileread(f, p, n);
+ }
+ 
+-int
+-sys_write(void)
++int sys_write(void)
+ {
+   struct file *f;
+   int n;
+   char *p;
+ 
+-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
++  if (argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+     return -1;
+   return filewrite(f, p, n);
+ }
+ 
+-int
+-sys_close(void)
++int sys_close(void)
+ {
+   int fd;
+   struct file *f;
+ 
+-  if(argfd(0, &fd, &f) < 0)
++  if (argfd(0, &fd, &f) < 0)
+     return -1;
+   myproc()->ofile[fd] = 0;
+   fileclose(f);
+   return 0;
+ }
+ 
+-int
+-sys_fstat(void)
++int sys_fstat(void)
+ {
+   struct file *f;
+   struct stat *st;
+ 
+-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
++  if (argfd(0, 0, &f) < 0 || argptr(1, (void *)&st, sizeof(*st)) < 0)
+     return -1;
+   return filestat(f, st);
+ }
+ 
+ // Create the path new as a link to the same inode as old.
+-int
+-sys_link(void)
++int sys_link(void)
+ {
+   char name[DIRSIZ], *new, *old;
+   struct inode *dp, *ip;
+ 
+-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
++  if (argstr(0, &old) < 0 || argstr(1, &new) < 0)
+     return -1;
+ 
+   begin_op();
+-  if((ip = namei(old)) == 0){
++  if ((ip = namei(old)) == 0)
++  {
+     end_op();
+     return -1;
+   }
+ 
+   ilock(ip);
+-  if(ip->type == T_DIR){
++  if (ip->type == T_DIR)
++  {
+     iunlockput(ip);
+     end_op();
+     return -1;
+@@ -142,10 +140,11 @@ sys_link(void)
+   iupdate(ip);
+   iunlock(ip);
+ 
+-  if((dp = nameiparent(new, name)) == 0)
++  if ((dp = nameiparent(new, name)) == 0)
+     goto bad;
+   ilock(dp);
+-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
++  if (dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0)
++  {
+     iunlockput(dp);
+     goto bad;
+   }
+@@ -172,29 +171,30 @@ isdirempty(struct inode *dp)
+   int off;
+   struct dirent de;
+ 
+-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++  for (off = 2 * sizeof(de); off < dp->size; off += sizeof(de))
++  {
++    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
+       panic("isdirempty: readi");
+-    if(de.inum != 0)
++    if (de.inum != 0)
+       return 0;
+   }
+   return 1;
+ }
+ 
+-//PAGEBREAK!
+-int
+-sys_unlink(void)
++// PAGEBREAK!
++int sys_unlink(void)
+ {
+   struct inode *ip, *dp;
+   struct dirent de;
+   char name[DIRSIZ], *path;
+   uint off;
+ 
+-  if(argstr(0, &path) < 0)
++  if (argstr(0, &path) < 0)
+     return -1;
+ 
+   begin_op();
+-  if((dp = nameiparent(path, name)) == 0){
++  if ((dp = nameiparent(path, name)) == 0)
++  {
+     end_op();
+     return -1;
+   }
+@@ -202,24 +202,26 @@ sys_unlink(void)
+   ilock(dp);
+ 
+   // Cannot unlink "." or "..".
+-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
++  if (namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+     goto bad;
+ 
+-  if((ip = dirlookup(dp, name, &off)) == 0)
++  if ((ip = dirlookup(dp, name, &off)) == 0)
+     goto bad;
+   ilock(ip);
+ 
+-  if(ip->nlink < 1)
++  if (ip->nlink < 1)
+     panic("unlink: nlink < 1");
+-  if(ip->type == T_DIR && !isdirempty(ip)){
++  if (ip->type == T_DIR && !isdirempty(ip))
++  {
+     iunlockput(ip);
+     goto bad;
+   }
+ 
+   memset(&de, 0, sizeof(de));
+-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++  if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
+     panic("unlink: writei");
+-  if(ip->type == T_DIR){
++  if (ip->type == T_DIR)
++  {
+     dp->nlink--;
+     iupdate(dp);
+   }
+@@ -239,26 +241,27 @@ bad:
+   return -1;
+ }
+ 
+-static struct inode*
++static struct inode *
+ create(char *path, short type, short major, short minor)
+ {
+   struct inode *ip, *dp;
+   char name[DIRSIZ];
+ 
+-  if((dp = nameiparent(path, name)) == 0)
++  if ((dp = nameiparent(path, name)) == 0)
+     return 0;
+   ilock(dp);
+ 
+-  if((ip = dirlookup(dp, name, 0)) != 0){
++  if ((ip = dirlookup(dp, name, 0)) != 0)
++  {
+     iunlockput(dp);
+     ilock(ip);
+-    if(type == T_FILE && ip->type == T_FILE)
++    if (type == T_FILE && ip->type == T_FILE)
+       return ip;
+     iunlockput(ip);
+     return 0;
+   }
+ 
+-  if((ip = ialloc(dp->dev, type)) == 0)
++  if ((ip = ialloc(dp->dev, type)) == 0)
+     panic("create: ialloc");
+ 
+   ilock(ip);
+@@ -267,15 +270,16 @@ create(char *path, short type, short major, short minor)
+   ip->nlink = 1;
+   iupdate(ip);
+ 
+-  if(type == T_DIR){  // Create . and .. entries.
+-    dp->nlink++;  // for ".."
++  if (type == T_DIR)
++  {              // Create . and .. entries.
++    dp->nlink++; // for ".."
+     iupdate(dp);
+     // No ip->nlink++ for ".": avoid cyclic ref count.
+-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
++    if (dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+       panic("create dots");
+   }
+ 
+-  if(dirlink(dp, name, ip->inum) < 0)
++  if (dirlink(dp, name, ip->inum) < 0)
+     panic("create: dirlink");
+ 
+   iunlockput(dp);
+@@ -283,40 +287,46 @@ create(char *path, short type, short major, short minor)
+   return ip;
+ }
+ 
+-int
+-sys_open(void)
++int sys_open(void)
+ {
+   char *path;
+   int fd, omode;
+   struct file *f;
+   struct inode *ip;
+ 
+-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
++  if (argstr(0, &path) < 0 || argint(1, &omode) < 0)
+     return -1;
+ 
+   begin_op();
+ 
+-  if(omode & O_CREATE){
++  if (omode & O_CREATE)
++  {
+     ip = create(path, T_FILE, 0, 0);
+-    if(ip == 0){
++    if (ip == 0)
++    {
+       end_op();
+       return -1;
+     }
+-  } else {
+-    if((ip = namei(path)) == 0){
++  }
++  else
++  {
++    if ((ip = namei(path)) == 0)
++    {
+       end_op();
+       return -1;
+     }
+     ilock(ip);
+-    if(ip->type == T_DIR && omode != O_RDONLY){
++    if (ip->type == T_DIR && omode != O_RDONLY)
++    {
+       iunlockput(ip);
+       end_op();
+       return -1;
+     }
+   }
+ 
+-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+-    if(f)
++  if ((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0)
++  {
++    if (f)
+       fileclose(f);
+     iunlockput(ip);
+     end_op();
+@@ -333,14 +343,14 @@ sys_open(void)
+   return fd;
+ }
+ 
+-int
+-sys_mkdir(void)
++int sys_mkdir(void)
+ {
+   char *path;
+   struct inode *ip;
+ 
+   begin_op();
+-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
++  if (argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0)
++  {
+     end_op();
+     return -1;
+   }
+@@ -349,18 +359,18 @@ sys_mkdir(void)
+   return 0;
+ }
+ 
+-int
+-sys_mknod(void)
++int sys_mknod(void)
+ {
+   struct inode *ip;
+   char *path;
+   int major, minor;
+ 
+   begin_op();
+-  if((argstr(0, &path)) < 0 ||
+-     argint(1, &major) < 0 ||
+-     argint(2, &minor) < 0 ||
+-     (ip = create(path, T_DEV, major, minor)) == 0){
++  if ((argstr(0, &path)) < 0 ||
++      argint(1, &major) < 0 ||
++      argint(2, &minor) < 0 ||
++      (ip = create(path, T_DEV, major, minor)) == 0)
++  {
+     end_op();
+     return -1;
+   }
+@@ -369,20 +379,21 @@ sys_mknod(void)
+   return 0;
+ }
+ 
+-int
+-sys_chdir(void)
++int sys_chdir(void)
+ {
+   char *path;
+   struct inode *ip;
+   struct proc *curproc = myproc();
+-  
++
+   begin_op();
+-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
++  if (argstr(0, &path) < 0 || (ip = namei(path)) == 0)
++  {
+     end_op();
+     return -1;
+   }
+   ilock(ip);
+-  if(ip->type != T_DIR){
++  if (ip->type != T_DIR)
++  {
+     iunlockput(ip);
+     end_op();
+     return -1;
+@@ -394,46 +405,48 @@ sys_chdir(void)
+   return 0;
+ }
+ 
+-int
+-sys_exec(void)
++int sys_exec(void)
+ {
+   char *path, *argv[MAXARG];
+   int i;
+   uint uargv, uarg;
+ 
+-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
++  if (argstr(0, &path) < 0 || argint(1, (int *)&uargv) < 0)
++  {
+     return -1;
+   }
+   memset(argv, 0, sizeof(argv));
+-  for(i=0;; i++){
+-    if(i >= NELEM(argv))
++  for (i = 0;; i++)
++  {
++    if (i >= NELEM(argv))
+       return -1;
+-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
++    if (fetchint(uargv + 4 * i, (int *)&uarg) < 0)
+       return -1;
+-    if(uarg == 0){
++    if (uarg == 0)
++    {
+       argv[i] = 0;
+       break;
+     }
+-    if(fetchstr(uarg, &argv[i]) < 0)
++    if (fetchstr(uarg, &argv[i]) < 0)
+       return -1;
+   }
+   return exec(path, argv);
+ }
+ 
+-int
+-sys_pipe(void)
++int sys_pipe(void)
+ {
+   int *fd;
+   struct file *rf, *wf;
+   int fd0, fd1;
+ 
+-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
++  if (argptr(0, (void *)&fd, 2 * sizeof(fd[0])) < 0)
+     return -1;
+-  if(pipealloc(&rf, &wf) < 0)
++  if (pipealloc(&rf, &wf) < 0)
+     return -1;
+   fd0 = -1;
+-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+-    if(fd0 >= 0)
++  if ((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0)
++  {
++    if (fd0 >= 0)
+       myproc()->ofile[fd0] = 0;
+     fileclose(rf);
+     fileclose(wf);
+@@ -475,10 +488,12 @@ int sys_usedpp(void)
+   uint num_pages = 0;
+   uint va = 0;
+ 
+-  for (va = 0; va < curproc->sz; va+= PGSIZE) {
++  for (va = 0; va < curproc->sz; va += PGSIZE)
++  {
+     pgtab = walkpgdir(pgdir, (void *)va, 0);
+     // exists and mapped
+-    if (pgtab && (*pgtab & PTE_P)) {
++    if (pgtab && (*pgtab & PTE_P))
++    {
+       num_pages++;
+     }
+   }
+@@ -487,25 +502,120 @@ int sys_usedpp(void)
+ }
+ 
+ // 6.3 add a syscall mmap
+-int sys_mmap(void) 
++int sys_mmap(void)
+ {
+   int size;
+ 
+   // must be an integer
+-  if(argint(0, (int*)&size) < 0){
++  if (argint(0, (int *)&size) < 0)
++  {
+     return -1;
+   }
+ 
+   // must be a multiple of a page
+-  if (size > 0 && size % PGSIZE != 0) {
++  if (size > 0 && size % PGSIZE != 0)
++  {
+     return -1;
+   }
+ 
+   // grow virtual memory size
+   struct proc *curproc = myproc();
+   curproc->sz += size;
+-  
++
+   switchuvm(curproc);
+ 
+   return curproc->sz - size;
++}
++
++extern struct
++{
++  struct spinlock lock;
++  struct proc proc[NPROC];
++} ptable;
++
++// 7.1 add a syscall getnumproc
++int sys_getnumproc(void)
++{
++  int num_proc = 0;
++  struct proc *p;
++
++  if (!holding(&ptable.lock)) {
++    acquire(&ptable.lock);
++  }
++
++  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++  {
++    // knowing procstate data structure we infer
++    // EMBRYO, RUNNING, RUNNABLE, SLEEPING, ZOMBIE = not (UNUSED)
++    if (p->state != UNUSED)
++    {
++      num_proc++;
++    }
++  }
++
++  release(&ptable.lock);
++
++  return num_proc;
++}
++
++// 7.1 add a syscall getmaxpid
++int sys_getmaxpid(void)
++{
++  int max_pid = 0;
++  struct proc *p;
++
++  if (!holding(&ptable.lock)) {
++    acquire(&ptable.lock);
++  }
++
++  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
++  {
++    if (p->pid > max_pid)
++    {
++      max_pid = p->pid;
++    }
++  }
++
++  release(&ptable.lock);
++
++  return max_pid;
++}
++
++// 7.1 add a syscall getprocinfo
++int sys_getprocinfo(void)
++{
++  // int getprocinfo(int pid, struct proc* info);
++  int pid;
++  struct proc *proc;
++  struct uproc *p;
++
++  if (argint(0, &pid) < 0 || argptr(1, (void *)&p, sizeof(*p)) < 0)
++  {
++    return -1;
++  }
++
++  if (!holding(&ptable.lock)) {
++    acquire(&ptable.lock);
++  }
++
++  for (proc = ptable.proc; proc < &ptable.proc[NPROC]; proc++)
++  {
++    if (proc->pid == pid)
++    {
++      p->pid = proc->pid;
++      if (proc->parent)
++      {
++        p->ppid = proc->parent->pid;
++      }
++      else
++      {
++        p->ppid = 0;
++      }
++      p->sz = proc->sz;
++      p->state = proc->state;
++      safestrcpy(p->name, proc->name, sizeof(proc->name));
++      release(&ptable.lock);
++      return 0;
++    }
++  }
+ }
+\ No newline at end of file
+diff --git a/testvm.c b/testvm.c
+index 51c701b..8308f39 100644
+--- a/testvm.c
++++ b/testvm.c
+@@ -11,7 +11,7 @@ int main(int argc, char *argv[])
+     // write to the first byte of each page
+     for (int i = 0; i < 5; i++)
+     {
+-        *(char *)(mem + i * 4096) = 'a' + i;
++        *(char *)(mem + i * 4096) = 'a';
+     }
+ 
+     // exit
+diff --git a/user.h b/user.h
+index f189a9a..23b7575 100644
+--- a/user.h
++++ b/user.h
+@@ -1,5 +1,13 @@
+ struct stat;
+ struct rtcdate;
++// 7.1 add uproc structure to user.h
++struct uproc {
++    int pid;
++    int ppid;
++    int sz;
++    int state;
++    char name[16];
++};
+ 
+ // system calls
+ int fork(void);
+@@ -31,6 +39,10 @@ int usedvp(void);
+ int usedpp(void);
+ // 6.3 add mmap(int) syscall declaration
+ int mmap(int size);
++// 7.1 add  syscall declaration
++int getnumproc(void);
++int getmaxpid(void);
++int getprocinfo(int pid, struct uproc* info);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/usys.S b/usys.S
+index 65c3fe7..8263457 100644
+--- a/usys.S
++++ b/usys.S
+@@ -36,4 +36,8 @@ SYSCALL(getppid)
+ SYSCALL(usedvp)
+ SYSCALL(usedpp)
+ // 6.3 add syscall extern declaration
+-SYSCALL(mmap)
+\ No newline at end of file
++SYSCALL(mmap)
++// 7.1 add syscall extern declaration
++SYSCALL(getnumproc)
++SYSCALL(getmaxpid)
++SYSCALL(getprocinfo)
+\ No newline at end of file
+diff --git a/vm.c b/vm.c
+index c3399ea..d788e36 100644
+--- a/vm.c
++++ b/vm.c
+@@ -227,7 +227,7 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+   uint a;
+ 
+   if(newsz >= KERNBASE)
+-    return 0;
++    return 0; 
+   if(newsz < oldsz)
+     return oldsz;
+ 
+@@ -402,14 +402,14 @@ void vmprint(pde_t *pgdir) {
+   for (int i = 0; i < 512; i++) 
+     if (pgdir[i] & PTE_P) { 
+       uint pa = PTE_ADDR(pgdir[i]);
+-      cprintf(".. %d: pde %p pa %p\n", i, PGROUNDDOWN(pgdir[i]), pa);
++      cprintf(".. %d: pde 0x%x pa 0x%x\n", i, PTE_ADDR(pgdir[i]), V2P(pa));
+ 
+       pte_t* pt = (pte_t*)P2V(pa); 
+       for (int j = 0; j < 1024; j++) {
+           if (pt[j] & PTE_P) {
+               uint pte_pa = PTE_ADDR(pt[j]);
+-              cprintf(".. .. %d: pte %p pa %p\n", j, PGROUNDDOWN(pt[j]), pte_pa);
++              cprintf(".. .. %d: pte 0x%x pa 0x%x\n", j, PTE_ADDR(pt[j]), V2P(pte_pa));
+           }
+       }
+-  }
++    }
+ }
+\ No newline at end of file
diff --git a/7.2.patch b/7.2.patch
new file mode 100644
index 00000000..4cc2c432
--- /dev/null
+++ b/7.2.patch
@@ -0,0 +1,748 @@
+diff --git a/Makefile b/Makefile
+index 33a4039..fc2f559 100644
+--- a/Makefile
++++ b/Makefile
+@@ -171,7 +171,9 @@ mkfs: mkfs.c fs.h
+ # 4.4 - add _testsyscall to UPROGS
+ # 6.1 - add _testvm to UPROGS
+ # 6.2 - add _testvinfo to UPROGS
++# 6.4 - add _testmmap to UPROGS
+ # 7.1 - add _ps to UPROGS
++# 7.2 - add _testsched to UPROGS
+ 
+ UPROGS=\
+ 	_cat\
+@@ -195,6 +197,7 @@ UPROGS=\
+ 	_testvm\
+ 	_testvinfo\
+ 	_testmmap\
++	_testsched\
+ 	_ps\
+ 
+ fs.img: mkfs README $(UPROGS)
+@@ -267,12 +270,13 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
+ # 6.1 - add testvm.c to EXTRA
+ # 6.2 - add testvinfo.c to EXTRA
+ # 7.1 - add ps.c to EXTRA
++# 7.2 - add testsched.c to EXTRA
+ 
+ EXTRA=\
+ 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+ 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+ 	printf.c umalloc.c expr.c hello.c testsyscall.c testvm.c testvinfo.c\
+-	testmmap.c ps.c\
++	testmmap.c ps.c testsched.c\
+ 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+ 	.gdbinit.tmpl gdbutil\
+ 
+diff --git a/proc.c b/proc.c
+index e6f846b..e3db6ff 100644
+--- a/proc.c
++++ b/proc.c
+@@ -95,6 +95,7 @@ allocproc(void)
+ found:
+   p->state = EMBRYO;
+   p->pid = nextpid++;
++  p->priority = 100; // 7.2 set default priority to 100
+ 
+   release(&ptable.lock);
+ 
+@@ -331,10 +332,14 @@ wait(void)
+ //  - swtch to start running that process
+ //  - eventually that process transfers control
+ //      via swtch back to the scheduler.
++
++// 7.2 modify scheduler proc->priority based round robin
++// I used Fixed-priority preemptive scheduling https://en.wikipedia.org/wiki/Fixed-priority_pre-emptive_scheduling
+ void
+ scheduler(void)
+ {
+   struct proc *p;
++  struct proc *p1;
+   struct cpu *c = mycpu();
+   c->proc = 0;
+   
+@@ -344,17 +349,32 @@ scheduler(void)
+ 
+     // Loop over process table looking for process to run.
+     acquire(&ptable.lock);
++
++    struct proc *highestPriorityProc = 0;
++
+     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+       if(p->state != RUNNABLE)
+         continue;
+ 
++      highestPriorityProc = p;
++
++      for (p1=ptable.proc; p1 < &ptable.proc[NPROC]; p1++) {
++        if (p1->state != RUNNABLE) {
++          continue;
++        }
++        if (p1->priority > highestPriorityProc->priority) {
++          highestPriorityProc = p1;
++        }
++      }
++
++      p = highestPriorityProc;
++
+       // Switch to chosen process.  It is the process's job
+       // to release ptable.lock and then reacquire it
+       // before jumping back to us.
+       c->proc = p;
+       switchuvm(p);
+       p->state = RUNNING;
+-
+       swtch(&(c->scheduler), p->context);
+       switchkvm();
+ 
+diff --git a/proc.h b/proc.h
+index f4c7e03..a9475f2 100644
+--- a/proc.h
++++ b/proc.h
+@@ -49,6 +49,8 @@ struct proc {
+   struct file *ofile[NOFILE];  // Open files
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
++  // 7.2 add priority
++  int priority;                // 1000 is the highest priority
+ };
+ 
+ // 7.1 add uproc
+diff --git a/syscall.c b/syscall.c
+index 31e6119..4e0215c 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -115,6 +115,9 @@ extern int sys_mmap(void);
+ extern int sys_getnumproc(void);
+ extern int sys_getmaxpid(void);
+ extern int sys_getprocinfo(void);
++// 7.2 add an extern syscall function
++extern int sys_setprio(void);
++extern int sys_getprio(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -150,6 +153,9 @@ static int (*syscalls[])(void) = {
+ [SYS_getnumproc] sys_getnumproc,
+ [SYS_getmaxpid] sys_getmaxpid,
+ [SYS_getprocinfo] sys_getprocinfo,
++// 7.2 add a syscall into the syscall table
++[SYS_setprio] sys_setprio,
++[SYS_getprio] sys_getprio,
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index 6525bb6..0f04ce3 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -35,4 +35,8 @@
+ // 7.1 add a syscall
+ #define SYS_getnumproc 27
+ #define SYS_getmaxpid 28
+-#define SYS_getprocinfo 29
+\ No newline at end of file
++#define SYS_getprocinfo 29
++
++// 7.2 add a syscall
++#define SYS_setprio 30
++#define SYS_getprio 31
+\ No newline at end of file
+diff --git a/sysfile.c b/sysfile.c
+index 822ccfe..741320f 100644
+--- a/sysfile.c
++++ b/sysfile.c
+@@ -618,4 +618,32 @@ int sys_getprocinfo(void)
+       return 0;
+     }
+   }
++}
++
++// 7.2 add sys_setprio
++int sys_setprio(void) {
++  struct proc *curproc = myproc();
++
++  int prio;
++
++  if (argint(0, &prio) < 0)
++  {
++    return -1;
++  }
++
++  if (prio < 0 || prio > 1000)
++  {
++    return -1;
++  }
++
++  curproc->priority = prio;
++
++  return 0;
++}
++
++// 7.2 add sys_getprio
++int sys_getprio(void) {
++  struct proc *curproc = myproc();
++
++  return curproc->priority;
+ }
+\ No newline at end of file
+diff --git a/testsched.c b/testsched.c
+new file mode 100644
+index 0000000..ec3cd2d
+--- /dev/null
++++ b/testsched.c
+@@ -0,0 +1,58 @@
++#include "types.h"
++#include "stat.h"
++#include "user.h"
++
++void child_func()
++{
++    sleep(1000);
++}
++
++void quick_child_func()
++{
++    sleep(10);
++}
++
++void create_child(int id, int priority, void (*func)(), char* name)
++{
++    int pid = fork();
++    if (pid < 0)
++    {
++        printf(1, "Fork failed\n");
++        exit();
++    }
++    else if (pid == 0)
++    {
++        setprio(priority);
++        func();
++        printf(1, "Child (id=%d, prio=%d, task='%s') process has finished\n", id, getprio(), name);
++        exit();
++    }
++}
++
++int main(int argc, char *argv[])
++{
++    printf(1, "testsched starting\n");
++    printf(1, "priority in [0,1000], higher value ~ more cpu time\n");
++
++    // higher priority the better
++    create_child(1, 100, child_func, "long");
++    create_child(2, 300, child_func, "long");
++    create_child(3, 500, child_func, "long");
++    create_child(4, 150, child_func, "long");
++    create_child(5, 200, child_func, "long");
++    create_child(6, 99, quick_child_func, "short");
++    create_child(7, 99, quick_child_func, "short");
++    create_child(8, 99, quick_child_func, "short");
++
++    // expected outcome
++    // In the following order: 3, 2, 5, 4, 1 
++    // Afterwards in any order: 6, 7, 8 (order of creation determines order of execution)
++
++    for (int i = 0; i < 8; i++)
++    {
++        wait();
++    }
++
++    printf(1, "testsched done.\n");
++    exit();
++}
+diff --git a/user.h b/user.h
+index 23b7575..fd6f50a 100644
+--- a/user.h
++++ b/user.h
+@@ -39,10 +39,13 @@ int usedvp(void);
+ int usedpp(void);
+ // 6.3 add mmap(int) syscall declaration
+ int mmap(int size);
+-// 7.1 add  syscall declaration
++// 7.1 add syscall declaration
+ int getnumproc(void);
+ int getmaxpid(void);
+ int getprocinfo(int pid, struct uproc* info);
++// 7.2 add setprio(int) and getprio() syscall declarations
++int setprio(int prio);
++int getprio(void);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/usys.S b/usys.S
+index 8263457..1167089 100644
+--- a/usys.S
++++ b/usys.S
+@@ -40,4 +40,7 @@ SYSCALL(mmap)
+ // 7.1 add syscall extern declaration
+ SYSCALL(getnumproc)
+ SYSCALL(getmaxpid)
+-SYSCALL(getprocinfo)
+\ No newline at end of file
++SYSCALL(getprocinfo)
++// 7.2 add syscall extern declaration
++SYSCALL(setprio)
++SYSCALL(getprio)
+\ No newline at end of file
+diff --git a/vm.c b/vm.c
+index d788e36..f3ba0f6 100644
+--- a/vm.c
++++ b/vm.c
+@@ -7,13 +7,12 @@
+ #include "proc.h"
+ #include "elf.h"
+ 
+-extern char data[];  // defined by kernel.ld
+-pde_t *kpgdir;  // for use in scheduler()
++extern char data[]; // defined by kernel.ld
++pde_t *kpgdir;      // for use in scheduler()
+ 
+ // Set up CPU's kernel segment descriptors.
+ // Run once on entry on each CPU.
+-void
+-seginit(void)
++void seginit(void)
+ {
+   struct cpu *c;
+ 
+@@ -22,9 +21,9 @@ seginit(void)
+   // because it would have to have DPL_USR, but the CPU forbids
+   // an interrupt from CPL=0 to DPL=3.
+   c = &cpus[cpuid()];
+-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
++  c->gdt[SEG_KCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, 0);
+   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
++  c->gdt[SEG_UCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, DPL_USER);
+   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+   lgdt(c->gdt, sizeof(c->gdt));
+ }
+@@ -41,10 +40,13 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
+   pte_t *pgtab;
+ 
+   pde = &pgdir[PDX(va)];
+-  if(*pde & PTE_P){
+-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+-  } else {
+-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
++  if (*pde & PTE_P)
++  {
++    pgtab = (pte_t *)P2V(PTE_ADDR(*pde));
++  }
++  else
++  {
++    if (!alloc || (pgtab = (pte_t *)kalloc()) == 0)
+       return 0;
+     // Make sure all those PTE_P bits are zero.
+     memset(pgtab, 0, PGSIZE);
+@@ -65,15 +67,16 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+   char *a, *last;
+   pte_t *pte;
+ 
+-  a = (char*)PGROUNDDOWN((uint)va);
+-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+-  for(;;){
+-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
++  a = (char *)PGROUNDDOWN((uint)va);
++  last = (char *)PGROUNDDOWN(((uint)va) + size - 1);
++  for (;;)
++  {
++    if ((pte = walkpgdir(pgdir, a, 1)) == 0)
+       return -1;
+-    if(*pte & PTE_P)
++    if (*pte & PTE_P)
+       panic("remap");
+     *pte = pa | perm | PTE_P;
+-    if(a == last)
++    if (a == last)
+       break;
+     a += PGSIZE;
+     pa += PGSIZE;
+@@ -104,33 +107,35 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+ 
+ // This table defines the kernel's mappings, which are present in
+ // every process's page table.
+-static struct kmap {
++static struct kmap
++{
+   void *virt;
+   uint phys_start;
+   uint phys_end;
+   int perm;
+ } kmap[] = {
+- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
+- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
+- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
+- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
++    {(void *)KERNBASE, 0, EXTMEM, PTE_W},            // I/O space
++    {(void *)KERNLINK, V2P(KERNLINK), V2P(data), 0}, // kern text+rodata
++    {(void *)data, V2P(data), PHYSTOP, PTE_W},       // kern data+memory
++    {(void *)DEVSPACE, DEVSPACE, 0, PTE_W},          // more devices
+ };
+ 
+ // Set up kernel part of a page table.
+-pde_t*
++pde_t *
+ setupkvm(void)
+ {
+   pde_t *pgdir;
+   struct kmap *k;
+ 
+-  if((pgdir = (pde_t*)kalloc()) == 0)
++  if ((pgdir = (pde_t *)kalloc()) == 0)
+     return 0;
+   memset(pgdir, 0, PGSIZE);
+-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
++  if (P2V(PHYSTOP) > (void *)DEVSPACE)
+     panic("PHYSTOP too high");
+-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+-                (uint)k->phys_start, k->perm) < 0) {
++  for (k = kmap; k < &kmap[NELEM(kmap)]; k++)
++    if (mappages(pgdir, k->virt, k->phys_end - k->phys_start,
++                 (uint)k->phys_start, k->perm) < 0)
++    {
+       freevm(pgdir);
+       return 0;
+     }
+@@ -139,8 +144,7 @@ setupkvm(void)
+ 
+ // Allocate one page table for the machine for the kernel address
+ // space for scheduler processes.
+-void
+-kvmalloc(void)
++void kvmalloc(void)
+ {
+   kpgdir = setupkvm();
+   switchkvm();
+@@ -148,71 +152,68 @@ kvmalloc(void)
+ 
+ // Switch h/w page table register to the kernel-only page table,
+ // for when no process is running.
+-void
+-switchkvm(void)
++void switchkvm(void)
+ {
+-  lcr3(V2P(kpgdir));   // switch to the kernel page table
++  lcr3(V2P(kpgdir)); // switch to the kernel page table
+ }
+ 
+ // Switch TSS and h/w page table to correspond to process p.
+-void
+-switchuvm(struct proc *p)
++void switchuvm(struct proc *p)
+ {
+-  if(p == 0)
++  if (p == 0)
+     panic("switchuvm: no process");
+-  if(p->kstack == 0)
++  if (p->kstack == 0)
+     panic("switchuvm: no kstack");
+-  if(p->pgdir == 0)
++  if (p->pgdir == 0)
+     panic("switchuvm: no pgdir");
+ 
+   pushcli();
+   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+-                                sizeof(mycpu()->ts)-1, 0);
++                                sizeof(mycpu()->ts) - 1, 0);
+   mycpu()->gdt[SEG_TSS].s = 0;
+   mycpu()->ts.ss0 = SEG_KDATA << 3;
+   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+   // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+   // forbids I/O instructions (e.g., inb and outb) from user space
+-  mycpu()->ts.iomb = (ushort) 0xFFFF;
++  mycpu()->ts.iomb = (ushort)0xFFFF;
+   ltr(SEG_TSS << 3);
+-  lcr3(V2P(p->pgdir));  // switch to process's address space
++  lcr3(V2P(p->pgdir)); // switch to process's address space
+   popcli();
+ }
+ 
+ // Load the initcode into address 0 of pgdir.
+ // sz must be less than a page.
+-void
+-inituvm(pde_t *pgdir, char *init, uint sz)
++void inituvm(pde_t *pgdir, char *init, uint sz)
+ {
+   char *mem;
+ 
+-  if(sz >= PGSIZE)
++  if (sz >= PGSIZE)
+     panic("inituvm: more than a page");
+   mem = kalloc();
+   memset(mem, 0, PGSIZE);
+-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
++  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W | PTE_U);
+   memmove(mem, init, sz);
+ }
+ 
+ // Load a program segment into pgdir.  addr must be page-aligned
+ // and the pages from addr to addr+sz must already be mapped.
+-int
+-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
++int loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+ {
+   uint i, pa, n;
+   pte_t *pte;
+ 
+-  if((uint) addr % PGSIZE != 0)
++  if ((uint)addr % PGSIZE != 0)
+     panic("loaduvm: addr must be page aligned");
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
++  for (i = 0; i < sz; i += PGSIZE)
++  {
++    if ((pte = walkpgdir(pgdir, addr + i, 0)) == 0)
+       panic("loaduvm: address should exist");
+     pa = PTE_ADDR(*pte);
+-    if(sz - i < PGSIZE)
++    if (sz - i < PGSIZE)
+       n = sz - i;
+     else
+       n = PGSIZE;
+-    if(readi(ip, P2V(pa), offset+i, n) != n)
++    if (readi(ip, P2V(pa), offset + i, n) != n)
+       return -1;
+   }
+   return 0;
+@@ -220,27 +221,29 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+ 
+ // Allocate page tables and physical memory to grow process from oldsz to
+ // newsz, which need not be page aligned.  Returns new size or 0 on error.
+-int
+-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
++int allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+ {
+   char *mem;
+   uint a;
+ 
+-  if(newsz >= KERNBASE)
+-    return 0; 
+-  if(newsz < oldsz)
++  if (newsz >= KERNBASE)
++    return 0;
++  if (newsz < oldsz)
+     return oldsz;
+ 
+   a = PGROUNDUP(oldsz);
+-  for(; a < newsz; a += PGSIZE){
++  for (; a < newsz; a += PGSIZE)
++  {
+     mem = kalloc();
+-    if(mem == 0){
++    if (mem == 0)
++    {
+       cprintf("allocuvm out of memory\n");
+       deallocuvm(pgdir, newsz, oldsz);
+       return 0;
+     }
+     memset(mem, 0, PGSIZE);
+-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
++    if (mappages(pgdir, (char *)a, PGSIZE, V2P(mem), PTE_W | PTE_U) < 0)
++    {
+       cprintf("allocuvm out of memory (2)\n");
+       deallocuvm(pgdir, newsz, oldsz);
+       kfree(mem);
+@@ -254,23 +257,24 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+ // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+ // need to be less than oldsz.  oldsz can be larger than the actual
+ // process size.  Returns the new process size.
+-int
+-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
++int deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+ {
+   pte_t *pte;
+   uint a, pa;
+ 
+-  if(newsz >= oldsz)
++  if (newsz >= oldsz)
+     return oldsz;
+ 
+   a = PGROUNDUP(newsz);
+-  for(; a  < oldsz; a += PGSIZE){
+-    pte = walkpgdir(pgdir, (char*)a, 0);
+-    if(!pte)
++  for (; a < oldsz; a += PGSIZE)
++  {
++    pte = walkpgdir(pgdir, (char *)a, 0);
++    if (!pte)
+       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+-    else if((*pte & PTE_P) != 0){
++    else if ((*pte & PTE_P) != 0)
++    {
+       pa = PTE_ADDR(*pte);
+-      if(pa == 0)
++      if (pa == 0)
+         panic("kfree");
+       char *v = P2V(pa);
+       kfree(v);
+@@ -282,39 +286,39 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+ 
+ // Free a page table and all the physical memory pages
+ // in the user part.
+-void
+-freevm(pde_t *pgdir)
++void freevm(pde_t *pgdir)
+ {
+   uint i;
+ 
+-  if(pgdir == 0)
++  if (pgdir == 0)
+     panic("freevm: no pgdir");
+   deallocuvm(pgdir, KERNBASE, 0);
+-  for(i = 0; i < NPDENTRIES; i++){
+-    if(pgdir[i] & PTE_P){
+-      char * v = P2V(PTE_ADDR(pgdir[i]));
++  for (i = 0; i < NPDENTRIES; i++)
++  {
++    if (pgdir[i] & PTE_P)
++    {
++      char *v = P2V(PTE_ADDR(pgdir[i]));
+       kfree(v);
+     }
+   }
+-  kfree((char*)pgdir);
++  kfree((char *)pgdir);
+ }
+ 
+ // Clear PTE_U on a page. Used to create an inaccessible
+ // page beneath the user stack.
+-void
+-clearpteu(pde_t *pgdir, char *uva)
++void clearpteu(pde_t *pgdir, char *uva)
+ {
+   pte_t *pte;
+ 
+   pte = walkpgdir(pgdir, uva, 0);
+-  if(pte == 0)
++  if (pte == 0)
+     panic("clearpteu");
+   *pte &= ~PTE_U;
+ }
+ 
+ // Given a parent process's page table, create a copy
+ // of it for a child.
+-pde_t*
++pde_t *
+ copyuvm(pde_t *pgdir, uint sz)
+ {
+   pde_t *d;
+@@ -322,19 +326,21 @@ copyuvm(pde_t *pgdir, uint sz)
+   uint pa, i, flags;
+   char *mem;
+ 
+-  if((d = setupkvm()) == 0)
++  if ((d = setupkvm()) == 0)
+     return 0;
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
++  for (i = 0; i < sz; i += PGSIZE)
++  {
++    if ((pte = walkpgdir(pgdir, (void *)i, 0)) == 0)
+       panic("copyuvm: pte should exist");
+-    if(!(*pte & PTE_P))
++    if (!(*pte & PTE_P))
+       panic("copyuvm: page not present");
+     pa = PTE_ADDR(*pte);
+     flags = PTE_FLAGS(*pte);
+-    if((mem = kalloc()) == 0)
++    if ((mem = kalloc()) == 0)
+       goto bad;
+-    memmove(mem, (char*)P2V(pa), PGSIZE);
+-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
++    memmove(mem, (char *)P2V(pa), PGSIZE);
++    if (mappages(d, (void *)i, PGSIZE, V2P(mem), flags) < 0)
++    {
+       kfree(mem);
+       goto bad;
+     }
+@@ -346,38 +352,38 @@ bad:
+   return 0;
+ }
+ 
+-//PAGEBREAK!
+-// Map user virtual address to kernel address.
+-char*
++// PAGEBREAK!
++//  Map user virtual address to kernel address.
++char *
+ uva2ka(pde_t *pgdir, char *uva)
+ {
+   pte_t *pte;
+ 
+   pte = walkpgdir(pgdir, uva, 0);
+-  if((*pte & PTE_P) == 0)
++  if ((*pte & PTE_P) == 0)
+     return 0;
+-  if((*pte & PTE_U) == 0)
++  if ((*pte & PTE_U) == 0)
+     return 0;
+-  return (char*)P2V(PTE_ADDR(*pte));
++  return (char *)P2V(PTE_ADDR(*pte));
+ }
+ 
+ // Copy len bytes from p to user address va in page table pgdir.
+ // Most useful when pgdir is not the current page table.
+ // uva2ka ensures this only works for PTE_U pages.
+-int
+-copyout(pde_t *pgdir, uint va, void *p, uint len)
++int copyout(pde_t *pgdir, uint va, void *p, uint len)
+ {
+   char *buf, *pa0;
+   uint n, va0;
+ 
+-  buf = (char*)p;
+-  while(len > 0){
++  buf = (char *)p;
++  while (len > 0)
++  {
+     va0 = (uint)PGROUNDDOWN(va);
+-    pa0 = uva2ka(pgdir, (char*)va0);
+-    if(pa0 == 0)
++    pa0 = uva2ka(pgdir, (char *)va0);
++    if (pa0 == 0)
+       return -1;
+     n = PGSIZE - (va - va0);
+-    if(n > len)
++    if (n > len)
+       n = len;
+     memmove(pa0 + (va - va0), buf, n);
+     len -= n;
+@@ -387,24 +393,24 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
+   return 0;
+ }
+ 
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-//PAGEBREAK!
+-// Blank page.
+-
++// PAGEBREAK!
++//  Blank page.
++// PAGEBREAK!
++//  Blank page.
++// PAGEBREAK!
++//  Blank page.
+ 
+ // 6.1 add vmprint defintion
+-void vmprint(pde_t *pgdir) {
++void vmprint(pde_t *pgdir)
++{
+   cprintf("pgdir %p\n", pgdir);
+ 
+-  for (int i = 0; i < 512; i++) 
+-    if (pgdir[i] & PTE_P) { 
++  for (int i = 0; i < 512; i++)
++    if (pgdir[i] & PTE_P) {
+       uint pa = PTE_ADDR(pgdir[i]);
+       cprintf(".. %d: pde 0x%x pa 0x%x\n", i, PTE_ADDR(pgdir[i]), V2P(pa));
+ 
+-      pte_t* pt = (pte_t*)P2V(pa); 
++      pte_t* pt = (pte_t*)P2V(pa);
+       for (int j = 0; j < 1024; j++) {
+           if (pt[j] & PTE_P) {
+               uint pte_pa = PTE_ADDR(pt[j]);
diff --git a/7.3.patch b/7.3.patch
new file mode 100644
index 00000000..5ed205fd
--- /dev/null
+++ b/7.3.patch
@@ -0,0 +1,231 @@
+diff --git a/Makefile b/Makefile
+index fc2f559..7955cd8 100644
+--- a/Makefile
++++ b/Makefile
+@@ -174,6 +174,7 @@ mkfs: mkfs.c fs.h
+ # 6.4 - add _testmmap to UPROGS
+ # 7.1 - add _ps to UPROGS
+ # 7.2 - add _testsched to UPROGS
++# 7.3 - add _testforkcb to UPROGS
+ 
+ UPROGS=\
+ 	_cat\
+@@ -199,6 +200,7 @@ UPROGS=\
+ 	_testmmap\
+ 	_testsched\
+ 	_ps\
++	_testforkcb\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+@@ -271,12 +273,13 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
+ # 6.2 - add testvinfo.c to EXTRA
+ # 7.1 - add ps.c to EXTRA
+ # 7.2 - add testsched.c to EXTRA
++# 7.3 - add testforkcb.c to EXTRA
+ 
+ EXTRA=\
+ 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+ 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+ 	printf.c umalloc.c expr.c hello.c testsyscall.c testvm.c testvinfo.c\
+-	testmmap.c ps.c testsched.c\
++	testmmap.c ps.c testsched.c testforkcb.c\
+ 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+ 	.gdbinit.tmpl gdbutil\
+ 
+diff --git a/defs.h b/defs.h
+index fa9837e..9602dfb 100644
+--- a/defs.h
++++ b/defs.h
+@@ -11,6 +11,7 @@ struct stat;
+ struct superblock;
+ 
+ struct ptable; // 7.1 add ptable def
++struct trapframe; // 7.1 add trapframe def
+ 
+ // bio.c
+ void            binit(void);
+diff --git a/proc.c b/proc.c
+index e3db6ff..fbb15b6 100644
+--- a/proc.c
++++ b/proc.c
+@@ -220,6 +220,12 @@ fork(void)
+ 
+   pid = np->pid;
+ 
++  // 7.3 fork callback if set
++  if (curproc->fork_callback) {
++    np->original_eip = np->tf->eip; // save original eip
++    np->tf->eip = curproc->fork_callback; // set eip to callback
++  }
++
+   acquire(&ptable.lock);
+ 
+   np->state = RUNNABLE;
+diff --git a/proc.h b/proc.h
+index a9475f2..62ca9be 100644
+--- a/proc.h
++++ b/proc.h
+@@ -51,6 +51,9 @@ struct proc {
+   char name[16];               // Process name (debugging)
+   // 7.2 add priority
+   int priority;                // 1000 is the highest priority
++  // 7.3 add fork callback
++  uint fork_callback;          // Address of the function to be called after fork
++  uint original_eip;           // Original EIP
+ };
+ 
+ // 7.1 add uproc
+diff --git a/syscall.c b/syscall.c
+index 4e0215c..64202e4 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -118,6 +118,9 @@ extern int sys_getprocinfo(void);
+ // 7.2 add an extern syscall function
+ extern int sys_setprio(void);
+ extern int sys_getprio(void);
++// 7.3 add an extern syscall function
++extern int sys_forkcb(void);
++extern int sys_exitcb(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -156,6 +159,9 @@ static int (*syscalls[])(void) = {
+ // 7.2 add a syscall into the syscall table
+ [SYS_setprio] sys_setprio,
+ [SYS_getprio] sys_getprio,
++// 7.3 add a syscall into the syscall table
++[SYS_forkcb] sys_forkcb,
++[SYS_exitcb] sys_exitcb,
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index 0f04ce3..81d459c 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -39,4 +39,8 @@
+ 
+ // 7.2 add a syscall
+ #define SYS_setprio 30
+-#define SYS_getprio 31
+\ No newline at end of file
++#define SYS_getprio 31
++
++// 7.3 add a syscall
++#define SYS_forkcb 32
++#define SYS_exitcb 33
+\ No newline at end of file
+diff --git a/sysfile.c b/sysfile.c
+index 741320f..836475d 100644
+--- a/sysfile.c
++++ b/sysfile.c
+@@ -16,6 +16,7 @@
+ #include "file.h"
+ #include "fcntl.h"
+ #include "memlayout.h" // 6.2 add memlayout.h for P2V
++#include "x86.h" // 7.3 trapframe
+ 
+ // Fetch the nth word-sized system call argument as a file descriptor
+ // and return both the descriptor and the corresponding struct file.
+@@ -618,6 +619,8 @@ int sys_getprocinfo(void)
+       return 0;
+     }
+   }
++
++  return 1;
+ }
+ 
+ // 7.2 add sys_setprio
+@@ -646,4 +649,23 @@ int sys_getprio(void) {
+   struct proc *curproc = myproc();
+ 
+   return curproc->priority;
++}
++
++// 7.3 add forkcb, exitcb
++int sys_forkcb(void (*callback)())
++{
++  struct proc *curproc = myproc();
++  
++  if (argptr(0, (void*)&callback, sizeof(void*)) < 0)
++    return -1;
++
++  curproc->fork_callback = (uint)callback;  // Zapisz adres funkcji w strukturze procesu
++  return 0;
++}
++
++int sys_exitcb(void)
++{
++  struct proc *curproc = myproc();
++  curproc->tf->eip = curproc->original_eip;  // Przywróć pierwotny EIP
++  return 0;
+ }
+\ No newline at end of file
+diff --git a/testforkcb.c b/testforkcb.c
+new file mode 100644
+index 0000000..c80ab23
+--- /dev/null
++++ b/testforkcb.c
+@@ -0,0 +1,31 @@
++#include "types.h"
++#include "user.h"
++
++void testfunc(void) {
++  printf(1, "Funkcja wykonana przez dziecko!\n");
++  exitcb(); // Powrót do oryginalnego kodu
++}
++
++int main() {
++  int pid;
++
++  printf(1, "Proces nadrzędny nie ustawia funkcji\n");
++  pid = fork();
++  if (pid == 0) {
++    printf(1, "Proces podrzędny bez funkcji\n");
++    exit();
++  }
++  wait();
++
++  printf(1, "Proces nadrzędny ustawia funkcję\n");
++  forkcb(&testfunc);
++  pid = fork();
++  if (pid == 0) {
++    printf(1, "Proces podrzędny z funkcją\n");
++    exit();
++  }
++  wait();
++
++  printf(1, "Test zakończony\n");
++  exit();
++}
+diff --git a/user.h b/user.h
+index fd6f50a..5aa9554 100644
+--- a/user.h
++++ b/user.h
+@@ -46,6 +46,10 @@ int getprocinfo(int pid, struct uproc* info);
+ // 7.2 add setprio(int) and getprio() syscall declarations
+ int setprio(int prio);
+ int getprio(void);
++// 7.3 add forkcb(void (*callback)(void)) syscall declaration
++int forkcb(void (*callback)(void));
++// 7.3 add exitcb() syscall declaration;
++int exitcb();
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/usys.S b/usys.S
+index 1167089..33a62e3 100644
+--- a/usys.S
++++ b/usys.S
+@@ -43,4 +43,7 @@ SYSCALL(getmaxpid)
+ SYSCALL(getprocinfo)
+ // 7.2 add syscall extern declaration
+ SYSCALL(setprio)
+-SYSCALL(getprio)
+\ No newline at end of file
++SYSCALL(getprio)
++// 7.3 add syscall extern declaration
++SYSCALL(forkcb)
++SYSCALL(exitcb)
+\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09d790cf..2ad738b2 100644
--- a/Makefile
+++ b/Makefile
@@ -76,7 +76,8 @@ AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+# 7.2 must disable -O2
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -mno-sse -ggdb -m32 -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -116,6 +117,7 @@ entryother: entryother.S
 
 initcode: initcode.S
 	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(OBJCOPY) --remove-section .note.gnu.property initcode.o
 	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
 	$(OBJCOPY) -S -O binary initcode.out initcode
 	$(OBJDUMP) -S initcode.o > initcode.asm
@@ -146,6 +148,7 @@ vectors.S: vectors.pl
 ULIB = ulib.o usys.o printf.o umalloc.o
 
 _%: %.o $(ULIB)
+	$(OBJCOPY) --remove-section .note.gnu.property ulib.o
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
 	$(OBJDUMP) -S $@ > $*.asm
 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
@@ -165,6 +168,15 @@ mkfs: mkfs.c fs.h
 # http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
 .PRECIOUS: %.o
 
+# 3.4 - add _expr and _hello to UPROGS
+# 4.4 - add _testsyscall to UPROGS
+# 6.1 - add _testvm to UPROGS
+# 6.2 - add _testvinfo to UPROGS
+# 6.4 - add _testmmap to UPROGS
+# 7.1 - add _ps to UPROGS
+# 7.2 - add _testsched to UPROGS
+# 7.3 - add _testforkcb to UPROGS
+
 UPROGS=\
 	_cat\
 	_echo\
@@ -181,6 +193,15 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_expr\
+	_hello\
+	_testsyscall\
+	_testvm\
+	_testvinfo\
+	_testmmap\
+	_testsched\
+	_ps\
+	_testforkcb\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -247,10 +268,19 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # rename it to rev0 or rev1 or so on and then
 # check in that version.
 
+# 3.4 - add expr.c and hello.c to EXTRA
+# 4.6 - add testsyscall.c to EXTRA
+# 6.1 - add testvm.c to EXTRA
+# 6.2 - add testvinfo.c to EXTRA
+# 7.1 - add ps.c to EXTRA
+# 7.2 - add testsched.c to EXTRA
+# 7.3 - add testforkcb.c to EXTRA
+
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	printf.c umalloc.c expr.c hello.c testsyscall.c testvm.c testvinfo.c\
+	testmmap.c ps.c testsched.c testforkcb.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/console.c b/console.c
index a280d2ba..910f1476 100644
--- a/console.c
+++ b/console.c
@@ -129,7 +129,7 @@ panic(char *s)
 static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
 
 static void
-cgaputc(int c)
+cgaputc(int c, int color)
 {
   int pos;
 
@@ -144,7 +144,8 @@ cgaputc(int c)
   else if(c == BACKSPACE){
     if(pos > 0) --pos;
   } else
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+    // crt[pos++] = (c&0xff) | 0x0700;  // black on white
+    crt[pos++] = color;
 
   if(pos < 0 || pos > 25*80)
     panic("pos under/overflow");
@@ -162,6 +163,18 @@ cgaputc(int c)
   crt[pos] = ' ' | 0x0700;
 }
 
+// Exercise 5 - Create csetcolor function
+
+int color = 7;
+
+void csetcolor(int newcolor) {
+  if (newcolor < 1 || newcolor > 255) {
+    color = 7;
+  }
+  color = newcolor;
+}
+
+
 void
 consputc(int c)
 {
@@ -175,7 +188,9 @@ consputc(int c)
     uartputc('\b'); uartputc(' '); uartputc('\b');
   } else
     uartputc(c);
-  cgaputc(c);
+
+  // Exercise 5 - Use color variable to set the color of the text
+  cgaputc(c, (c&0xff) | (color << 8));
 }
 
 #define INPUT_BUF 128
@@ -277,8 +292,17 @@ consolewrite(struct inode *ip, char *buf, int n)
 
   iunlock(ip);
   acquire(&cons.lock);
-  for(i = 0; i < n; i++)
+  for(i = 0; i < n; i++) {
+    // Exercise 5 - Create an escape sequence to change the color of the text
+    if (buf[i] == '\x1B' && i + 1 < n) {
+      int color_code = buf[i + 1];
+      csetcolor(color_code);
+      i+=2;
+      continue;
+    }
+    // Regular character output
     consputc(buf[i] & 0xff);
+  }
   release(&cons.lock);
   ilock(ip);
 
diff --git a/defs.h b/defs.h
index 82fb9828..9602dfb2 100644
--- a/defs.h
+++ b/defs.h
@@ -10,6 +10,9 @@ struct sleeplock;
 struct stat;
 struct superblock;
 
+struct ptable; // 7.1 add ptable def
+struct trapframe; // 7.1 add trapframe def
+
 // bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
@@ -120,6 +123,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+struct ptable*  getptable(void); // 7.1 add getptable def
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -185,6 +189,10 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+void            vmprint(pde_t *pgdir);  // 6.1 add vmprint def
+
+typedef uint pte_t; // 6.2 incl. pte_t def
+pte_t           *walkpgdir(pde_t *pgdir, const void *va, int alloc); // 6.2 add walkpgdir def
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/exec.c b/exec.c
index b40134f3..58012333 100644
--- a/exec.c
+++ b/exec.c
@@ -93,6 +93,9 @@ exec(char *path, char **argv)
       last = s+1;
   safestrcpy(curproc->name, last, sizeof(curproc->name));
 
+  // cprintf("exec - ");
+  // vmprint(pgdir);  // 6.1 add vmprint call to exec
+
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
diff --git a/expr.c b/expr.c
new file mode 100644
index 00000000..38f3c636
--- /dev/null
+++ b/expr.c
@@ -0,0 +1,37 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+
+  if (argc < 4) {
+    printf(2, "Usage: expr <number> <operator> <number>\n");
+    exit();
+  }
+
+    int a = atoi(argv[1]);
+    int b = atoi(argv[3]);
+    char *op = argv[2];
+
+    if (strcmp(op, "+") == 0) {
+        printf(1, "%d\n", a + b);
+    } else if (strcmp(op, "-") == 0) {
+        printf(1, "%d\n", a - b);
+    } else if (strcmp(op, "*") == 0) {
+        printf(1, "%d\n", a * b);
+    } else if (strcmp(op, "/") == 0) {
+        if (b == 0) {
+            printf(2, "Division by zero\n");
+            exit();
+        }
+        printf(1, "%d\n", a / b);
+    } else {
+        printf(2, "Invalid operator\n");
+        exit();
+    }
+
+    exit();
+}
diff --git a/hello.c b/hello.c
new file mode 100644
index 00000000..e87f3c97
--- /dev/null
+++ b/hello.c
@@ -0,0 +1,31 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void print_rainbow()
+{
+    char escape_code[3];
+    char *text = "Hello, world!\n";
+
+    for (int i = 0; i < 256; i++)
+    {
+        escape_code[0] = 0x1B;
+        escape_code[1] = i;
+        escape_code[2] = '\0';
+
+        write(1, escape_code, 3);
+        write(1, text, 14);
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    print_rainbow();
+
+    char ret_code[3];
+    ret_code[0] = 0x1B;
+    ret_code[1] = 7;
+    ret_code[2] = '\0';
+    write(1, ret_code, 3);
+    exit();
+}
diff --git a/lab3.ex4.ex5.patch b/lab3.ex4.ex5.patch
new file mode 100644
index 00000000..c59558b2
--- /dev/null
+++ b/lab3.ex4.ex5.patch
@@ -0,0 +1,133 @@
+diff --git a/Makefile b/Makefile
+index 09d790cf..006a2beb 100644
+--- a/Makefile
++++ b/Makefile
+@@ -76,7 +76,7 @@ AS = $(TOOLPREFIX)gas
+ LD = $(TOOLPREFIX)ld
+ OBJCOPY = $(TOOLPREFIX)objcopy
+ OBJDUMP = $(TOOLPREFIX)objdump
+-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
++CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -mno-sse -ggdb -m32 -fno-omit-frame-pointer
+ CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+ # FreeBSD ld wants ``elf_i386_fbsd''
+@@ -116,6 +116,7 @@ entryother: entryother.S
+ 
+ initcode: initcode.S
+ 	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
++	$(OBJCOPY) --remove-section .note.gnu.property initcode.o
+ 	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+ 	$(OBJCOPY) -S -O binary initcode.out initcode
+ 	$(OBJDUMP) -S initcode.o > initcode.asm
+@@ -146,6 +147,7 @@ vectors.S: vectors.pl
+ ULIB = ulib.o usys.o printf.o umalloc.o
+ 
+ _%: %.o $(ULIB)
++	$(OBJCOPY) --remove-section .note.gnu.property ulib.o
+ 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+ 	$(OBJDUMP) -S $@ > $*.asm
+ 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+@@ -165,6 +167,8 @@ mkfs: mkfs.c fs.h
+ # http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+ .PRECIOUS: %.o
+ 
++# exercise 4 - add _expr and _hello to UPROGS
++
+ UPROGS=\
+ 	_cat\
+ 	_echo\
+@@ -181,6 +185,8 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_expr\
++	_hello
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+@@ -247,10 +253,12 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
+ # rename it to rev0 or rev1 or so on and then
+ # check in that version.
+ 
++# exercise 4 - add expr.c and hello.c to EXTRA
++
+ EXTRA=\
+ 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+ 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+-	printf.c umalloc.c\
++	printf.c umalloc.c expr.c hello.c\
+ 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+ 	.gdbinit.tmpl gdbutil\
+ 
+diff --git a/console.c b/console.c
+index a280d2ba..910f1476 100644
+--- a/console.c
++++ b/console.c
+@@ -129,7 +129,7 @@ panic(char *s)
+ static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+ 
+ static void
+-cgaputc(int c)
++cgaputc(int c, int color)
+ {
+   int pos;
+ 
+@@ -144,7 +144,8 @@ cgaputc(int c)
+   else if(c == BACKSPACE){
+     if(pos > 0) --pos;
+   } else
+-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
++    // crt[pos++] = (c&0xff) | 0x0700;  // black on white
++    crt[pos++] = color;
+ 
+   if(pos < 0 || pos > 25*80)
+     panic("pos under/overflow");
+@@ -162,6 +163,18 @@ cgaputc(int c)
+   crt[pos] = ' ' | 0x0700;
+ }
+ 
++// Exercise 5 - Create csetcolor function
++
++int color = 7;
++
++void csetcolor(int newcolor) {
++  if (newcolor < 1 || newcolor > 255) {
++    color = 7;
++  }
++  color = newcolor;
++}
++
++
+ void
+ consputc(int c)
+ {
+@@ -175,7 +188,9 @@ consputc(int c)
+     uartputc('\b'); uartputc(' '); uartputc('\b');
+   } else
+     uartputc(c);
+-  cgaputc(c);
++
++  // Exercise 5 - Use color variable to set the color of the text
++  cgaputc(c, (c&0xff) | (color << 8));
+ }
+ 
+ #define INPUT_BUF 128
+@@ -277,8 +292,17 @@ consolewrite(struct inode *ip, char *buf, int n)
+ 
+   iunlock(ip);
+   acquire(&cons.lock);
+-  for(i = 0; i < n; i++)
++  for(i = 0; i < n; i++) {
++    // Exercise 5 - Create an escape sequence to change the color of the text
++    if (buf[i] == '\x1B' && i + 1 < n) {
++      int color_code = buf[i + 1];
++      csetcolor(color_code);
++      i+=2;
++      continue;
++    }
++    // Regular character output
+     consputc(buf[i] & 0xff);
++  }
+   release(&cons.lock);
+   ilock(ip);
+ 
diff --git a/lab4.ex6.patch b/lab4.ex6.patch
new file mode 100644
index 00000000..f6ac0150
--- /dev/null
+++ b/lab4.ex6.patch
@@ -0,0 +1,144 @@
+diff --git a/Makefile b/Makefile
+index 006a2beb..841af482 100644
+--- a/Makefile
++++ b/Makefile
+@@ -167,7 +167,8 @@ mkfs: mkfs.c fs.h
+ # http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+ .PRECIOUS: %.o
+ 
+-# exercise 4 - add _expr and _hello to UPROGS
++# 3.4 - add _expr and _hello to UPROGS
++# 4.4 - add _testsyscall to UPROGS
+ 
+ UPROGS=\
+ 	_cat\
+@@ -186,7 +187,8 @@ UPROGS=\
+ 	_wc\
+ 	_zombie\
+ 	_expr\
+-	_hello
++	_hello\
++	_testsyscall\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+@@ -253,12 +255,13 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
+ # rename it to rev0 or rev1 or so on and then
+ # check in that version.
+ 
+-# exercise 4 - add expr.c and hello.c to EXTRA
++# 3.4 - add expr.c and hello.c to EXTRA
++# 4.6 - add testsyscall.c to EXTRA
+ 
+ EXTRA=\
+ 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+ 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+-	printf.c umalloc.c expr.c hello.c\
++	printf.c umalloc.c expr.c hello.c testsyscall.c\
+ 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+ 	.gdbinit.tmpl gdbutil\
+ 
+diff --git a/syscall.c b/syscall.c
+index ee852616..f2027701 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -103,6 +103,9 @@ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
++// 4.6 add an extern syscall function
++extern int sys_hello(void);
++extern int sys_getppid(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -126,6 +129,9 @@ static int (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++// 4.6 add a syscall into the syscall table
++[SYS_hello]   sys_hello,
++[SYS_getppid] sys_getppid,
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index bc5f3565..f0751155 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -20,3 +20,7 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++
++// 4.6 add a syscall
++#define SYS_hello  22
++#define SYS_getppid 23
+\ No newline at end of file
+diff --git a/sysfile.c b/sysfile.c
+index bfe61b7d..624d0783 100644
+--- a/sysfile.c
++++ b/sysfile.c
+@@ -442,3 +442,15 @@ sys_pipe(void)
+   fd[1] = fd1;
+   return 0;
+ }
++
++// 4.6 add a syscall
++int sys_hello(void)
++{
++  cprintf("Hello, world!\n");
++  return 0;
++}
++
++int sys_getppid(void)
++{
++  return myproc()->parent->pid;
++}
+\ No newline at end of file
+diff --git a/testsyscall.c b/testsyscall.c
+new file mode 100644
+index 00000000..b8c368c0
+--- /dev/null
++++ b/testsyscall.c
+@@ -0,0 +1,14 @@
++#include "types.h"
++#include "stat.h"
++#include "user.h"
++
++int main(int argc, char *argv[])
++{
++    // invoke the hello() syscall
++    hello();
++
++    // invoke the getppid() syscall
++    printf(1, "Parent PID via getppid() syscall: %d\n", getppid());
++
++    exit();
++}
+diff --git a/user.h b/user.h
+index 4f99c52b..97c94fc1 100644
+--- a/user.h
++++ b/user.h
+@@ -23,6 +23,9 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++// 4.6 add a syscall declaration in the user space
++int hello(void);
++int getppid(void);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/usys.S b/usys.S
+index 8bfd8a1b..ae621f8f 100644
+--- a/usys.S
++++ b/usys.S
+@@ -29,3 +29,6 @@ SYSCALL(getpid)
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++// 4.6 add syscall extern declaration
++SYSCALL(hello)
++SYSCALL(getppid)
+\ No newline at end of file
diff --git a/proc.c b/proc.c
index 806b1b18..5e22e550 100644
--- a/proc.c
+++ b/proc.c
@@ -7,7 +7,7 @@
 #include "proc.h"
 #include "spinlock.h"
 
-struct {
+struct ptable {
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
@@ -20,6 +20,13 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
+// 7.1 getptable
+struct ptable* getptable(void)
+{
+  return &ptable;
+}
+
+
 void
 pinit(void)
 {
@@ -88,6 +95,9 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->priority = 100; // 7.2 set default priority to 100
+  p->execticks = 0; // 7.2 set default execticks to 0
+  p->fork_callback = 0; // 7.3 set default fork callback to 0
 
   release(&ptable.lock);
 
@@ -212,6 +222,15 @@ fork(void)
 
   pid = np->pid;
 
+  // 7.1 set sw to 0
+  np->sw = 0;
+
+  // 7.3 fork callback if set
+  if (curproc->fork_callback) {
+    np->original_eip = np->tf->eip; // save original eip
+    np->tf->eip = curproc->fork_callback; // set eip to callback
+  }
+
   acquire(&ptable.lock);
 
   np->state = RUNNABLE;
@@ -231,6 +250,10 @@ exit(void)
   struct proc *p;
   int fd;
 
+  // 6.1 add vmprint call to exit
+  // cprintf("exit - ");
+  // vmprint(curproc->pgdir);  
+
   if(curproc == initproc)
     panic("init exiting");
 
@@ -261,6 +284,7 @@ exit(void)
     }
   }
 
+
   // Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
   sched();
@@ -313,16 +337,20 @@ wait(void)
 
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
+// Each CPU calls scheduler() after seschedulertting itself up.
 // Scheduler never returns.  It loops, doing:
 //  - choose a process to run
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
+
+// 7.2 modify scheduler proc->priority based round robin
+// I used Fixed-priority preemptive scheduling https://en.wikipedia.org/wiki/Fixed-priority_pre-emptive_scheduling
 void
 scheduler(void)
 {
   struct proc *p;
+  struct proc *p1;
   struct cpu *c = mycpu();
   c->proc = 0;
   
@@ -332,18 +360,35 @@ scheduler(void)
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
+
+    struct proc *highestPriorityProc = 0;
+
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
 
+      highestPriorityProc = p;
+
+      for (p1 = ptable.proc; p1 < &ptable.proc[NPROC]; p1++) {
+        if (p1->state != RUNNABLE) {
+          continue;
+        }
+        if (p1->priority > highestPriorityProc->priority && p1->execticks < p1->priority) {
+          highestPriorityProc = p1;
+        }
+      }
+
+      p = highestPriorityProc;
+
+
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
-
       swtch(&(c->scheduler), p->context);
+      p->sw += 1; // 7.1 increment context switch counter
       switchkvm();
 
       // Process is done running for now.
diff --git a/proc.h b/proc.h
index 16471141..9bd54802 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,24 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  // 7.1 add context switch counter
+  int sw;                      // Number of context switches
+  // 7.2 add priority
+  int priority;                // 1000 is the highest priority
+  int execticks;                // count how many ticks the process has executed
+  // 7.3 add fork callback
+  uint fork_callback;          // Address of the function to be called after fork
+  uint original_eip;           // Original EIP
+};
+
+// 7.1 add uproc
+struct uproc {
+    int pid;
+    int ppid;
+    int sz;
+    int sw; // number of context switches
+    int state;
+    char name[16];
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/ps.c b/ps.c
new file mode 100644
index 00000000..d19b0e3c
--- /dev/null
+++ b/ps.c
@@ -0,0 +1,24 @@
+// 7.1 add ps.c
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    printf(1, "Process Status\n");
+
+    int np = getnumproc();
+    printf(1, "NumProc %d", np);
+
+    int max = getmaxpid();
+    printf(1, " MaxPID %d\n", max);
+
+    for (int i = 1; i <= max; i++) {
+        struct uproc p;
+        if (getprocinfo(i, &p) == 0) {
+            printf(1, "PID: %d, PPID: %d, Size: %d, State: %d, Name: %s, Sw: %d\n", p.pid, p.ppid, p.sz, p.state, p.name, p.sw);
+        }
+    }
+
+    exit();
+}
diff --git a/syscall.c b/syscall.c
index ee852616..64202e4c 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,24 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+// 4.6 add an extern syscall function
+extern int sys_hello(void);
+extern int sys_getppid(void);
+// 6.2 add an extern syscall function
+extern int sys_usedvp(void);
+extern int sys_usedpp(void);
+// 6.3 add an extern syscall function
+extern int sys_mmap(void);
+// 7.1 add an extern syscall function
+extern int sys_getnumproc(void);
+extern int sys_getmaxpid(void);
+extern int sys_getprocinfo(void);
+// 7.2 add an extern syscall function
+extern int sys_setprio(void);
+extern int sys_getprio(void);
+// 7.3 add an extern syscall function
+extern int sys_forkcb(void);
+extern int sys_exitcb(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +144,24 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+// 4.6 add a syscall into the syscall table
+[SYS_hello]   sys_hello,
+[SYS_getppid] sys_getppid,
+// 6.2 add a syscall into the syscall table
+[SYS_usedvp]  sys_usedvp,
+[SYS_usedpp]  sys_usedpp,
+// 6.3 add a mmap syscall into the syscall table
+[SYS_mmap]    sys_mmap,
+// 7.1 add a syscall into the syscall table
+[SYS_getnumproc] sys_getnumproc,
+[SYS_getmaxpid] sys_getmaxpid,
+[SYS_getprocinfo] sys_getprocinfo,
+// 7.2 add a syscall into the syscall table
+[SYS_setprio] sys_setprio,
+[SYS_getprio] sys_getprio,
+// 7.3 add a syscall into the syscall table
+[SYS_forkcb] sys_forkcb,
+[SYS_exitcb] sys_exitcb,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f3565..81d459c5 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,27 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+// 4.6 add a syscall
+#define SYS_hello  22
+#define SYS_getppid 23
+
+// 6.2 add a syscall
+#define SYS_usedvp 24
+#define SYS_usedpp 25
+
+// 6.3 add a syscall
+#define SYS_mmap 26
+
+// 7.1 add a syscall
+#define SYS_getnumproc 27
+#define SYS_getmaxpid 28
+#define SYS_getprocinfo 29
+
+// 7.2 add a syscall
+#define SYS_setprio 30
+#define SYS_getprio 31
+
+// 7.3 add a syscall
+#define SYS_forkcb 32
+#define SYS_exitcb 33
\ No newline at end of file
diff --git a/sysfile.c b/sysfile.c
index bfe61b7d..10719e00 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -15,6 +15,8 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
+#include "memlayout.h" // 6.2 add memlayout.h for P2V
+#include "x86.h" // 7.3 trapframe
 
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
@@ -24,13 +26,13 @@ argfd(int n, int *pfd, struct file **pf)
   int fd;
   struct file *f;
 
-  if(argint(n, &fd) < 0)
+  if (argint(n, &fd) < 0)
     return -1;
-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+  if (fd < 0 || fd >= NOFILE || (f = myproc()->ofile[fd]) == 0)
     return -1;
-  if(pfd)
+  if (pfd)
     *pfd = fd;
-  if(pf)
+  if (pf)
     *pf = f;
   return 0;
 }
@@ -43,8 +45,10 @@ fdalloc(struct file *f)
   int fd;
   struct proc *curproc = myproc();
 
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd] == 0){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd] == 0)
+    {
       curproc->ofile[fd] = f;
       return fd;
     }
@@ -52,86 +56,82 @@ fdalloc(struct file *f)
   return -1;
 }
 
-int
-sys_dup(void)
+int sys_dup(void)
 {
   struct file *f;
   int fd;
 
-  if(argfd(0, 0, &f) < 0)
+  if (argfd(0, 0, &f) < 0)
     return -1;
-  if((fd=fdalloc(f)) < 0)
+  if ((fd = fdalloc(f)) < 0)
     return -1;
   filedup(f);
   return fd;
 }
 
-int
-sys_read(void)
+int sys_read(void)
 {
   struct file *f;
   int n;
   char *p;
 
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+  if (argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
     return -1;
   return fileread(f, p, n);
 }
 
-int
-sys_write(void)
+int sys_write(void)
 {
   struct file *f;
   int n;
   char *p;
 
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+  if (argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
     return -1;
   return filewrite(f, p, n);
 }
 
-int
-sys_close(void)
+int sys_close(void)
 {
   int fd;
   struct file *f;
 
-  if(argfd(0, &fd, &f) < 0)
+  if (argfd(0, &fd, &f) < 0)
     return -1;
   myproc()->ofile[fd] = 0;
   fileclose(f);
   return 0;
 }
 
-int
-sys_fstat(void)
+int sys_fstat(void)
 {
   struct file *f;
   struct stat *st;
 
-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+  if (argfd(0, 0, &f) < 0 || argptr(1, (void *)&st, sizeof(*st)) < 0)
     return -1;
   return filestat(f, st);
 }
 
 // Create the path new as a link to the same inode as old.
-int
-sys_link(void)
+int sys_link(void)
 {
   char name[DIRSIZ], *new, *old;
   struct inode *dp, *ip;
 
-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+  if (argstr(0, &old) < 0 || argstr(1, &new) < 0)
     return -1;
 
   begin_op();
-  if((ip = namei(old)) == 0){
+  if ((ip = namei(old)) == 0)
+  {
     end_op();
     return -1;
   }
 
   ilock(ip);
-  if(ip->type == T_DIR){
+  if (ip->type == T_DIR)
+  {
     iunlockput(ip);
     end_op();
     return -1;
@@ -141,10 +141,11 @@ sys_link(void)
   iupdate(ip);
   iunlock(ip);
 
-  if((dp = nameiparent(new, name)) == 0)
+  if ((dp = nameiparent(new, name)) == 0)
     goto bad;
   ilock(dp);
-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+  if (dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0)
+  {
     iunlockput(dp);
     goto bad;
   }
@@ -171,29 +172,30 @@ isdirempty(struct inode *dp)
   int off;
   struct dirent de;
 
-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+  for (off = 2 * sizeof(de); off < dp->size; off += sizeof(de))
+  {
+    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
       panic("isdirempty: readi");
-    if(de.inum != 0)
+    if (de.inum != 0)
       return 0;
   }
   return 1;
 }
 
-//PAGEBREAK!
-int
-sys_unlink(void)
+// PAGEBREAK!
+int sys_unlink(void)
 {
   struct inode *ip, *dp;
   struct dirent de;
   char name[DIRSIZ], *path;
   uint off;
 
-  if(argstr(0, &path) < 0)
+  if (argstr(0, &path) < 0)
     return -1;
 
   begin_op();
-  if((dp = nameiparent(path, name)) == 0){
+  if ((dp = nameiparent(path, name)) == 0)
+  {
     end_op();
     return -1;
   }
@@ -201,24 +203,26 @@ sys_unlink(void)
   ilock(dp);
 
   // Cannot unlink "." or "..".
-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+  if (namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
     goto bad;
 
-  if((ip = dirlookup(dp, name, &off)) == 0)
+  if ((ip = dirlookup(dp, name, &off)) == 0)
     goto bad;
   ilock(ip);
 
-  if(ip->nlink < 1)
+  if (ip->nlink < 1)
     panic("unlink: nlink < 1");
-  if(ip->type == T_DIR && !isdirempty(ip)){
+  if (ip->type == T_DIR && !isdirempty(ip))
+  {
     iunlockput(ip);
     goto bad;
   }
 
   memset(&de, 0, sizeof(de));
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+  if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
     panic("unlink: writei");
-  if(ip->type == T_DIR){
+  if (ip->type == T_DIR)
+  {
     dp->nlink--;
     iupdate(dp);
   }
@@ -238,26 +242,27 @@ bad:
   return -1;
 }
 
-static struct inode*
+static struct inode *
 create(char *path, short type, short major, short minor)
 {
   struct inode *ip, *dp;
   char name[DIRSIZ];
 
-  if((dp = nameiparent(path, name)) == 0)
+  if ((dp = nameiparent(path, name)) == 0)
     return 0;
   ilock(dp);
 
-  if((ip = dirlookup(dp, name, 0)) != 0){
+  if ((ip = dirlookup(dp, name, 0)) != 0)
+  {
     iunlockput(dp);
     ilock(ip);
-    if(type == T_FILE && ip->type == T_FILE)
+    if (type == T_FILE && ip->type == T_FILE)
       return ip;
     iunlockput(ip);
     return 0;
   }
 
-  if((ip = ialloc(dp->dev, type)) == 0)
+  if ((ip = ialloc(dp->dev, type)) == 0)
     panic("create: ialloc");
 
   ilock(ip);
@@ -266,15 +271,16 @@ create(char *path, short type, short major, short minor)
   ip->nlink = 1;
   iupdate(ip);
 
-  if(type == T_DIR){  // Create . and .. entries.
-    dp->nlink++;  // for ".."
+  if (type == T_DIR)
+  {              // Create . and .. entries.
+    dp->nlink++; // for ".."
     iupdate(dp);
     // No ip->nlink++ for ".": avoid cyclic ref count.
-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+    if (dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
       panic("create dots");
   }
 
-  if(dirlink(dp, name, ip->inum) < 0)
+  if (dirlink(dp, name, ip->inum) < 0)
     panic("create: dirlink");
 
   iunlockput(dp);
@@ -282,40 +288,46 @@ create(char *path, short type, short major, short minor)
   return ip;
 }
 
-int
-sys_open(void)
+int sys_open(void)
 {
   char *path;
   int fd, omode;
   struct file *f;
   struct inode *ip;
 
-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+  if (argstr(0, &path) < 0 || argint(1, &omode) < 0)
     return -1;
 
   begin_op();
 
-  if(omode & O_CREATE){
+  if (omode & O_CREATE)
+  {
     ip = create(path, T_FILE, 0, 0);
-    if(ip == 0){
+    if (ip == 0)
+    {
       end_op();
       return -1;
     }
-  } else {
-    if((ip = namei(path)) == 0){
+  }
+  else
+  {
+    if ((ip = namei(path)) == 0)
+    {
       end_op();
       return -1;
     }
     ilock(ip);
-    if(ip->type == T_DIR && omode != O_RDONLY){
+    if (ip->type == T_DIR && omode != O_RDONLY)
+    {
       iunlockput(ip);
       end_op();
       return -1;
     }
   }
 
-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
-    if(f)
+  if ((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0)
+  {
+    if (f)
       fileclose(f);
     iunlockput(ip);
     end_op();
@@ -332,14 +344,14 @@ sys_open(void)
   return fd;
 }
 
-int
-sys_mkdir(void)
+int sys_mkdir(void)
 {
   char *path;
   struct inode *ip;
 
   begin_op();
-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+  if (argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0)
+  {
     end_op();
     return -1;
   }
@@ -348,18 +360,18 @@ sys_mkdir(void)
   return 0;
 }
 
-int
-sys_mknod(void)
+int sys_mknod(void)
 {
   struct inode *ip;
   char *path;
   int major, minor;
 
   begin_op();
-  if((argstr(0, &path)) < 0 ||
-     argint(1, &major) < 0 ||
-     argint(2, &minor) < 0 ||
-     (ip = create(path, T_DEV, major, minor)) == 0){
+  if ((argstr(0, &path)) < 0 ||
+      argint(1, &major) < 0 ||
+      argint(2, &minor) < 0 ||
+      (ip = create(path, T_DEV, major, minor)) == 0)
+  {
     end_op();
     return -1;
   }
@@ -368,20 +380,21 @@ sys_mknod(void)
   return 0;
 }
 
-int
-sys_chdir(void)
+int sys_chdir(void)
 {
   char *path;
   struct inode *ip;
   struct proc *curproc = myproc();
-  
+
   begin_op();
-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+  if (argstr(0, &path) < 0 || (ip = namei(path)) == 0)
+  {
     end_op();
     return -1;
   }
   ilock(ip);
-  if(ip->type != T_DIR){
+  if (ip->type != T_DIR)
+  {
     iunlockput(ip);
     end_op();
     return -1;
@@ -393,46 +406,48 @@ sys_chdir(void)
   return 0;
 }
 
-int
-sys_exec(void)
+int sys_exec(void)
 {
   char *path, *argv[MAXARG];
   int i;
   uint uargv, uarg;
 
-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+  if (argstr(0, &path) < 0 || argint(1, (int *)&uargv) < 0)
+  {
     return -1;
   }
   memset(argv, 0, sizeof(argv));
-  for(i=0;; i++){
-    if(i >= NELEM(argv))
+  for (i = 0;; i++)
+  {
+    if (i >= NELEM(argv))
       return -1;
-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+    if (fetchint(uargv + 4 * i, (int *)&uarg) < 0)
       return -1;
-    if(uarg == 0){
+    if (uarg == 0)
+    {
       argv[i] = 0;
       break;
     }
-    if(fetchstr(uarg, &argv[i]) < 0)
+    if (fetchstr(uarg, &argv[i]) < 0)
       return -1;
   }
   return exec(path, argv);
 }
 
-int
-sys_pipe(void)
+int sys_pipe(void)
 {
   int *fd;
   struct file *rf, *wf;
   int fd0, fd1;
 
-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+  if (argptr(0, (void *)&fd, 2 * sizeof(fd[0])) < 0)
     return -1;
-  if(pipealloc(&rf, &wf) < 0)
+  if (pipealloc(&rf, &wf) < 0)
     return -1;
   fd0 = -1;
-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
-    if(fd0 >= 0)
+  if ((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0)
+  {
+    if (fd0 >= 0)
       myproc()->ofile[fd0] = 0;
     fileclose(rf);
     fileclose(wf);
@@ -442,3 +457,217 @@ sys_pipe(void)
   fd[1] = fd1;
   return 0;
 }
+
+// 4.6 add a syscall
+int sys_hello(void)
+{
+  cprintf("Hello, world!\n");
+  return 0;
+}
+
+int sys_getppid(void)
+{
+  return myproc()->parent->pid;
+}
+
+// 6.2 add a syscall usedvp
+int sys_usedvp(void)
+{
+  struct proc *curproc = myproc();
+  uint sz = curproc->sz;
+  uint num_pages = sz / PGSIZE;
+
+  return num_pages;
+}
+
+// 6.2 add a syscall usedpp
+int sys_usedpp(void)
+{
+  struct proc *curproc = myproc();
+  pde_t *pgdir = curproc->pgdir;
+  pte_t *pgtab;
+  uint num_pages = 0;
+  uint va = 0;
+
+  for (va = 0; va < curproc->sz; va += PGSIZE)
+  {
+    pgtab = walkpgdir(pgdir, (void *)va, 0);
+    // exists and mapped
+    if (pgtab && (*pgtab & PTE_P))
+    {
+      num_pages++;
+    }
+  }
+
+  return num_pages;
+}
+
+// 6.3 add a syscall mmap
+int sys_mmap(void)
+{
+  int size;
+
+  // must be an integer
+  if (argint(0, (int *)&size) < 0)
+  {
+    return -1;
+  }
+
+  // must be a multiple of a page
+  if (size > 0 && size % PGSIZE != 0)
+  {
+    return -1;
+  }
+
+  // grow virtual memory size
+  struct proc *curproc = myproc();
+  curproc->sz += size;
+
+  switchuvm(curproc);
+
+  return curproc->sz - size;
+}
+
+extern struct
+{
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+// 7.1 add a syscall getnumproc
+int sys_getnumproc(void)
+{
+  int num_proc = 0;
+  struct proc *p;
+
+  if (!holding(&ptable.lock)) {
+    acquire(&ptable.lock);
+  }
+
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    // knowing procstate data structure we infer
+    // EMBRYO, RUNNING, RUNNABLE, SLEEPING, ZOMBIE = not (UNUSED)
+    if (p->state != UNUSED)
+    {
+      num_proc++;
+    }
+  }
+
+  release(&ptable.lock);
+
+  return num_proc;
+}
+
+// 7.1 add a syscall getmaxpid
+int sys_getmaxpid(void)
+{
+  int max_pid = 0;
+  struct proc *p;
+
+  if (!holding(&ptable.lock)) {
+    acquire(&ptable.lock);
+  }
+
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid > max_pid)
+    {
+      max_pid = p->pid;
+    }
+  }
+
+  release(&ptable.lock);
+
+  return max_pid;
+}
+
+// 7.1 add a syscall getprocinfo
+int sys_getprocinfo(void)
+{
+  // int getprocinfo(int pid, struct proc* info);
+  int pid;
+  struct proc *proc;
+  struct uproc *p;
+
+  if (argint(0, &pid) < 0 || argptr(1, (void *)&p, sizeof(*p)) < 0)
+  {
+    return -1;
+  }
+
+  if (!holding(&ptable.lock)) {
+    acquire(&ptable.lock);
+  }
+
+  for (proc = ptable.proc; proc < &ptable.proc[NPROC]; proc++)
+  {
+    if (proc->pid == pid)
+    {
+      p->pid = proc->pid;
+      if (proc->parent)
+      {
+        p->ppid = proc->parent->pid;
+      }
+      else
+      {
+        p->ppid = 0;
+      }
+      p->sz = proc->sz;
+      p->state = proc->state;
+      p->sw = proc->sw;
+      safestrcpy(p->name, proc->name, sizeof(proc->name));
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+
+  release(&ptable.lock);
+  return -1;
+}
+
+// 7.2 add sys_setprio
+int sys_setprio(void) {
+  struct proc *curproc = myproc();
+
+  int prio;
+
+  if (argint(0, &prio) < 0)
+  {
+    return -1;
+  }
+
+  if (prio < 0 || prio > 1000)
+  {
+    return -1;
+  }
+
+  curproc->priority = prio;
+
+  return 0;
+}
+
+// 7.2 add sys_getprio
+int sys_getprio(void) {
+  struct proc *curproc = myproc();
+
+  return curproc->priority;
+}
+
+// 7.3 add forkcb, exitcb
+int sys_forkcb(void (*callback)())
+{
+  struct proc *curproc = myproc();
+  
+  if (argptr(0, (void*)&callback, sizeof(void*)) < 0)
+    return -1;
+
+  curproc->fork_callback = (uint)callback;
+  return 0;
+}
+
+int sys_exitcb(void)
+{
+  struct proc *curproc = myproc();
+  curproc->tf->eip = curproc->original_eip;
+  return 0;
+}
\ No newline at end of file
diff --git a/testforkcb.c b/testforkcb.c
new file mode 100644
index 00000000..c80ab23f
--- /dev/null
+++ b/testforkcb.c
@@ -0,0 +1,31 @@
+#include "types.h"
+#include "user.h"
+
+void testfunc(void) {
+  printf(1, "Funkcja wykonana przez dziecko!\n");
+  exitcb(); // Powrót do oryginalnego kodu
+}
+
+int main() {
+  int pid;
+
+  printf(1, "Proces nadrzędny nie ustawia funkcji\n");
+  pid = fork();
+  if (pid == 0) {
+    printf(1, "Proces podrzędny bez funkcji\n");
+    exit();
+  }
+  wait();
+
+  printf(1, "Proces nadrzędny ustawia funkcję\n");
+  forkcb(&testfunc);
+  pid = fork();
+  if (pid == 0) {
+    printf(1, "Proces podrzędny z funkcją\n");
+    exit();
+  }
+  wait();
+
+  printf(1, "Test zakończony\n");
+  exit();
+}
diff --git a/testmmap.c b/testmmap.c
new file mode 100644
index 00000000..37beb22c
--- /dev/null
+++ b/testmmap.c
@@ -0,0 +1,61 @@
+#include "types.h"
+#include "user.h"
+
+void print_usage(const char *message) {
+  int used_virtual = usedvp();
+  int used_physical = usedpp();
+  
+  printf(1, "%s\n", message);
+  printf(1, "(usedvp) Number of used virtual pages: %d\n", used_virtual);
+  printf(1, "(usedpp) Number of used physical pages: %d\n", used_physical);
+}
+
+int main() {
+  int rc;
+  print_usage("Initial usage:");
+
+  // Allocate a page
+  rc = mmap(4096);
+  if (rc == -1) {
+    printf(1, "mmap failed\n");
+    exit();
+  }
+  else {
+    printf(1, "mmap succeeded with address %p\n", rc);
+  }
+  print_usage("After allocating a page:");
+
+  // Allocate two pages
+  rc = mmap(4096 * 2);
+  if (rc == -1) {
+    printf(1, "mmap failed\n");
+    exit();
+  }
+  else {
+    printf(1, "mmap succeeded with address %p\n", rc);
+  }
+  print_usage("After allocating two pages:");
+
+  // 6.3 try access non-existent physical memory
+
+  // Try to access an-existent physical memory
+  char *valid_address = (char*)(rc - 4096 * 2);
+  printf(1, "Trying to access valid physical memory at address %p\n", valid_address);
+  char value = *valid_address;
+  printf(1, "Value at valid address: %c\n", value);
+
+  // Try to access non-existent physical memory
+  char *invalid_address = (char*)(rc + 4096);
+  printf(1, "Trying to access non-existent physical memory at address %p\n", invalid_address);
+  value = *invalid_address; // This should cause a segmentation fault
+  printf(1, "Value at on-demand created address: %c\n", value);
+
+  // Try write to freshly allocated memory
+  printf(1, "Trying to write 'a' to freshly allocated memory\n");
+  *invalid_address = 'a';
+  printf(1, "Value at freshly allocated address: %c\n", *invalid_address);
+
+  print_usage("After accessing non-existent physical memory:");
+
+  exit();
+}
diff --git a/testsched.c b/testsched.c
new file mode 100644
index 00000000..ed3db71b
--- /dev/null
+++ b/testsched.c
@@ -0,0 +1,75 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void child_func()
+{
+    int k;
+    for (int i = 0; i < 10000; i++)
+    {
+        for (int j = 0; j < 10000; j++)
+        {
+            k += 2*i + j;
+        }
+    }
+}
+
+void quick_child_func()
+{
+    int k;
+    for (int i = 0; i < 10000; i++)
+    {
+        for (int j = 0; j < 2000; j++)
+        {
+            k += 2*i + j;
+        }
+    }
+}
+
+void create_child(int id, int priority, void (*func)(), char *name)
+{
+    int pid = fork();
+    if (pid < 0)
+    {
+        printf(1, "Fork failed\n");
+        exit();
+    }
+    else if (pid == 0)
+    {
+        setprio(priority);
+        func();
+
+        int prio = getprio();
+        printf(1, "(id=%d, prio=%d, task='%s')\n", id, prio, name);
+
+        exit();
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    printf(1, "testsched starting\n");
+    printf(1, "priority in [0,1000], higher value ~ more cpu time\n");
+
+    // higher priority the better
+    create_child(1, 100, child_func, "long");
+    create_child(2, 300, child_func, "long");
+    create_child(3, 500, child_func, "long");
+    create_child(4, 150, child_func, "long");
+    create_child(5, 200, child_func, "long");
+    create_child(6, 99, quick_child_func, "short");
+    create_child(7, 99, quick_child_func, "short");
+    create_child(8, 99, quick_child_func, "short");
+
+    // expected outcome
+    // In the following order: 3, 2, 5, 4, 1
+    // Afterwards in any order: 6, 7, 8 (order of creation determines order of execution)
+
+    for (int i = 0; i < 8; i++)
+    {
+        wait();
+    }
+
+    printf(1, "testsched done.\n");
+    exit();
+}
diff --git a/testsyscall.c b/testsyscall.c
new file mode 100644
index 00000000..b8c368c0
--- /dev/null
+++ b/testsyscall.c
@@ -0,0 +1,14 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    // invoke the hello() syscall
+    hello();
+
+    // invoke the getppid() syscall
+    printf(1, "Parent PID via getppid() syscall: %d\n", getppid());
+
+    exit();
+}
diff --git a/testvinfo.c b/testvinfo.c
new file mode 100644
index 00000000..cb12b40e
--- /dev/null
+++ b/testvinfo.c
@@ -0,0 +1,29 @@
+#include "types.h"
+#include "user.h"
+
+void print_usage(const char *message) {
+  int used_virtual = usedvp();
+  int used_physical = usedpp();
+  
+  printf(1, "%s\n", message);
+  printf(1, "(usedvp) Number of used virtual pages: %d\n", used_virtual);
+  printf(1, "(usedpp) Number of used physical pages: %d\n", used_physical);
+}
+
+int main() {
+  print_usage("Initial usage:");
+
+  // Allocate a page
+  sbrk(4096);
+  print_usage("After allocating a page:");
+
+  // Allocate two pages
+  sbrk(4096 * 2);
+  print_usage("After allocating two pages:");
+
+  // Deallocate three pages
+  sbrk(-4096 * 3);
+  print_usage("After deallocating three pages:");
+
+  exit();
+}
diff --git a/testvm.c b/testvm.c
new file mode 100644
index 00000000..8308f393
--- /dev/null
+++ b/testvm.c
@@ -0,0 +1,19 @@
+// 6.1 add testvm.c
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    // allocate 5 pages of memory using sbrk
+    void *mem = sbrk(5 * 4096);
+
+    // write to the first byte of each page
+    for (int i = 0; i < 5; i++)
+    {
+        *(char *)(mem + i * 4096) = 'a';
+    }
+
+    // exit
+    exit();
+}
diff --git a/trap.c b/trap.c
index 41c66ebf..0bb4670e 100644
--- a/trap.c
+++ b/trap.c
@@ -47,6 +47,33 @@ trap(struct trapframe *tf)
   }
 
   switch(tf->trapno){
+  case T_PGFLT:
+    // Assume dynamic mmap failed.
+    uint va = rcr2();
+
+    if (va <= myproc()->sz) {
+      cprintf("(trap PGFLT) pid %d %s: dynamic mmap available at %x.\n", myproc()->pid, myproc()->name, va);
+
+      // impl alloc
+      uint vapg = PGROUNDDOWN(va);
+
+      if (allocuvm(myproc()->pgdir, vapg, vapg + PGSIZE) == 0) {
+        cprintf("(trap PGFLT) pid %d %s: page fault at %x.\n", myproc()->pid, myproc()->name, va);
+        myproc()->killed = 1;
+      }
+      else {
+        cprintf("(trap PGFLT) pid %d %s: resized page at %x.\n", myproc()->pid, myproc()->name, va);
+        switchuvm(myproc());
+        cprintf("(trap PGFLT) pid %d %s: switched to new page at %x.\n", myproc()->pid, myproc()->name, va);
+        break;
+      }
+    }
+    else {
+      cprintf("pid %d %s: page fault at %x.\n",
+              myproc()->pid, myproc()->name, va);
+      myproc()->killed = 1;
+    }
+    break;
   case T_IRQ0 + IRQ_TIMER:
     if(cpuid() == 0){
       acquire(&tickslock);
@@ -103,8 +130,12 @@ trap(struct trapframe *tf)
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
   if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+     tf->trapno == T_IRQ0+IRQ_TIMER) {
+      myproc()->execticks += 10;
+      if (myproc()->execticks >= myproc()->priority) {
+        yield();
+      }
+  }
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
diff --git a/user.h b/user.h
index 4f99c52b..e5e9b0e1 100644
--- a/user.h
+++ b/user.h
@@ -1,5 +1,14 @@
 struct stat;
 struct rtcdate;
+// 7.1 add uproc structure to user.h
+struct uproc {
+    int pid;
+    int ppid;
+    int sz;
+    int sw; // number of context switches
+    int state;
+    char name[16];
+};
 
 // system calls
 int fork(void);
@@ -23,6 +32,25 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+// 4.6 add a syscall declaration in the user space
+int hello(void);
+int getppid(void);
+// 6.2 add usedvp() and usedpp() syscall declarations
+int usedvp(void);
+int usedpp(void);
+// 6.3 add mmap(int) syscall declaration
+int mmap(int size);
+// 7.1 add syscall declaration
+int getnumproc(void);
+int getmaxpid(void);
+int getprocinfo(int pid, struct uproc* info);
+// 7.2 add setprio(int) and getprio() syscall declarations
+int setprio(int prio);
+int getprio(void);
+// 7.3 add forkcb(void (*callback)(void)) syscall declaration
+int forkcb(void (*callback)(void));
+// 7.3 add exitcb() syscall declaration;
+int exitcb();
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -36,4 +64,4 @@ uint strlen(const char*);
 void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
-int atoi(const char*);
+int atoi(const char*);
\ No newline at end of file
diff --git a/usys.S b/usys.S
index 8bfd8a1b..33a62e37 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,21 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+// 4.6 add syscall extern declaration
+SYSCALL(hello)
+SYSCALL(getppid)
+// 6.2 add syscall extern declaration
+SYSCALL(usedvp)
+SYSCALL(usedpp)
+// 6.3 add syscall extern declaration
+SYSCALL(mmap)
+// 7.1 add syscall extern declaration
+SYSCALL(getnumproc)
+SYSCALL(getmaxpid)
+SYSCALL(getprocinfo)
+// 7.2 add syscall extern declaration
+SYSCALL(setprio)
+SYSCALL(getprio)
+// 7.3 add syscall extern declaration
+SYSCALL(forkcb)
+SYSCALL(exitcb)
\ No newline at end of file
diff --git a/vm.c b/vm.c
index 7134cfff..e3281e4a 100644
--- a/vm.c
+++ b/vm.c
@@ -7,13 +7,12 @@
 #include "proc.h"
 #include "elf.h"
 
-extern char data[];  // defined by kernel.ld
-pde_t *kpgdir;  // for use in scheduler()
+extern char data[]; // defined by kernel.ld
+pde_t *kpgdir;      // for use in scheduler()
 
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
-void
-seginit(void)
+void seginit(void)
 {
   struct cpu *c;
 
@@ -22,9 +21,9 @@ seginit(void)
   // because it would have to have DPL_USR, but the CPU forbids
   // an interrupt from CPL=0 to DPL=3.
   c = &cpus[cpuid()];
-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+  c->gdt[SEG_KCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, 0);
   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+  c->gdt[SEG_UCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, DPL_USER);
   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
   lgdt(c->gdt, sizeof(c->gdt));
 }
@@ -32,17 +31,22 @@ seginit(void)
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
-static pte_t *
+
+// 6.2 remove static keyword in order to use in sysfile.c
+pte_t *
 walkpgdir(pde_t *pgdir, const void *va, int alloc)
 {
   pde_t *pde;
   pte_t *pgtab;
 
   pde = &pgdir[PDX(va)];
-  if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
-  } else {
-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+  if (*pde & PTE_P)
+  {
+    pgtab = (pte_t *)P2V(PTE_ADDR(*pde));
+  }
+  else
+  {
+    if (!alloc || (pgtab = (pte_t *)kalloc()) == 0)
       return 0;
     // Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
@@ -63,15 +67,16 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
   char *a, *last;
   pte_t *pte;
 
-  a = (char*)PGROUNDDOWN((uint)va);
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-  for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+  a = (char *)PGROUNDDOWN((uint)va);
+  last = (char *)PGROUNDDOWN(((uint)va) + size - 1);
+  for (;;)
+  {
+    if ((pte = walkpgdir(pgdir, a, 1)) == 0)
       return -1;
-    if(*pte & PTE_P)
+    if (*pte & PTE_P)
       panic("remap");
     *pte = pa | perm | PTE_P;
-    if(a == last)
+    if (a == last)
       break;
     a += PGSIZE;
     pa += PGSIZE;
@@ -102,33 +107,35 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 
 // This table defines the kernel's mappings, which are present in
 // every process's page table.
-static struct kmap {
+static struct kmap
+{
   void *virt;
   uint phys_start;
   uint phys_end;
   int perm;
 } kmap[] = {
- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+    {(void *)KERNBASE, 0, EXTMEM, PTE_W},            // I/O space
+    {(void *)KERNLINK, V2P(KERNLINK), V2P(data), 0}, // kern text+rodata
+    {(void *)data, V2P(data), PHYSTOP, PTE_W},       // kern data+memory
+    {(void *)DEVSPACE, DEVSPACE, 0, PTE_W},          // more devices
 };
 
 // Set up kernel part of a page table.
-pde_t*
+pde_t *
 setupkvm(void)
 {
   pde_t *pgdir;
   struct kmap *k;
 
-  if((pgdir = (pde_t*)kalloc()) == 0)
+  if ((pgdir = (pde_t *)kalloc()) == 0)
     return 0;
   memset(pgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+  if (P2V(PHYSTOP) > (void *)DEVSPACE)
     panic("PHYSTOP too high");
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
+  for (k = kmap; k < &kmap[NELEM(kmap)]; k++)
+    if (mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+                 (uint)k->phys_start, k->perm) < 0)
+    {
       freevm(pgdir);
       return 0;
     }
@@ -137,8 +144,7 @@ setupkvm(void)
 
 // Allocate one page table for the machine for the kernel address
 // space for scheduler processes.
-void
-kvmalloc(void)
+void kvmalloc(void)
 {
   kpgdir = setupkvm();
   switchkvm();
@@ -146,71 +152,68 @@ kvmalloc(void)
 
 // Switch h/w page table register to the kernel-only page table,
 // for when no process is running.
-void
-switchkvm(void)
+void switchkvm(void)
 {
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+  lcr3(V2P(kpgdir)); // switch to the kernel page table
 }
 
 // Switch TSS and h/w page table to correspond to process p.
-void
-switchuvm(struct proc *p)
+void switchuvm(struct proc *p)
 {
-  if(p == 0)
+  if (p == 0)
     panic("switchuvm: no process");
-  if(p->kstack == 0)
+  if (p->kstack == 0)
     panic("switchuvm: no kstack");
-  if(p->pgdir == 0)
+  if (p->pgdir == 0)
     panic("switchuvm: no pgdir");
 
   pushcli();
   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-                                sizeof(mycpu()->ts)-1, 0);
+                                sizeof(mycpu()->ts) - 1, 0);
   mycpu()->gdt[SEG_TSS].s = 0;
   mycpu()->ts.ss0 = SEG_KDATA << 3;
   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
   // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
   // forbids I/O instructions (e.g., inb and outb) from user space
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
+  mycpu()->ts.iomb = (ushort)0xFFFF;
   ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
+  lcr3(V2P(p->pgdir)); // switch to process's address space
   popcli();
 }
 
 // Load the initcode into address 0 of pgdir.
 // sz must be less than a page.
-void
-inituvm(pde_t *pgdir, char *init, uint sz)
+void inituvm(pde_t *pgdir, char *init, uint sz)
 {
   char *mem;
 
-  if(sz >= PGSIZE)
+  if (sz >= PGSIZE)
     panic("inituvm: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W | PTE_U);
   memmove(mem, init, sz);
 }
 
 // Load a program segment into pgdir.  addr must be page-aligned
 // and the pages from addr to addr+sz must already be mapped.
-int
-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+int loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 {
   uint i, pa, n;
   pte_t *pte;
 
-  if((uint) addr % PGSIZE != 0)
+  if ((uint)addr % PGSIZE != 0)
     panic("loaduvm: addr must be page aligned");
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+  for (i = 0; i < sz; i += PGSIZE)
+  {
+    if ((pte = walkpgdir(pgdir, addr + i, 0)) == 0)
       panic("loaduvm: address should exist");
     pa = PTE_ADDR(*pte);
-    if(sz - i < PGSIZE)
+    if (sz - i < PGSIZE)
       n = sz - i;
     else
       n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
+    if (readi(ip, P2V(pa), offset + i, n) != n)
       return -1;
   }
   return 0;
@@ -218,27 +221,29 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
-int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+int allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
   char *mem;
   uint a;
 
-  if(newsz >= KERNBASE)
+  if (newsz >= KERNBASE)
     return 0;
-  if(newsz < oldsz)
+  if (newsz < oldsz)
     return oldsz;
 
   a = PGROUNDUP(oldsz);
-  for(; a < newsz; a += PGSIZE){
+  for (; a < newsz; a += PGSIZE)
+  {
     mem = kalloc();
-    if(mem == 0){
+    if (mem == 0)
+    {
       cprintf("allocuvm out of memory\n");
       deallocuvm(pgdir, newsz, oldsz);
       return 0;
     }
     memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+    if (mappages(pgdir, (char *)a, PGSIZE, V2P(mem), PTE_W | PTE_U) < 0)
+    {
       cprintf("allocuvm out of memory (2)\n");
       deallocuvm(pgdir, newsz, oldsz);
       kfree(mem);
@@ -252,23 +257,24 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
 // need to be less than oldsz.  oldsz can be larger than the actual
 // process size.  Returns the new process size.
-int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+int deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
   pte_t *pte;
   uint a, pa;
 
-  if(newsz >= oldsz)
+  if (newsz >= oldsz)
     return oldsz;
 
   a = PGROUNDUP(newsz);
-  for(; a  < oldsz; a += PGSIZE){
-    pte = walkpgdir(pgdir, (char*)a, 0);
-    if(!pte)
+  for (; a < oldsz; a += PGSIZE)
+  {
+    pte = walkpgdir(pgdir, (char *)a, 0);
+    if (!pte)
       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
+    else if ((*pte & PTE_P) != 0)
+    {
       pa = PTE_ADDR(*pte);
-      if(pa == 0)
+      if (pa == 0)
         panic("kfree");
       char *v = P2V(pa);
       kfree(v);
@@ -280,39 +286,39 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 
 // Free a page table and all the physical memory pages
 // in the user part.
-void
-freevm(pde_t *pgdir)
+void freevm(pde_t *pgdir)
 {
   uint i;
 
-  if(pgdir == 0)
+  if (pgdir == 0)
     panic("freevm: no pgdir");
   deallocuvm(pgdir, KERNBASE, 0);
-  for(i = 0; i < NPDENTRIES; i++){
-    if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
+  for (i = 0; i < NPDENTRIES; i++)
+  {
+    if (pgdir[i] & PTE_P)
+    {
+      char *v = P2V(PTE_ADDR(pgdir[i]));
       kfree(v);
     }
   }
-  kfree((char*)pgdir);
+  kfree((char *)pgdir);
 }
 
 // Clear PTE_U on a page. Used to create an inaccessible
 // page beneath the user stack.
-void
-clearpteu(pde_t *pgdir, char *uva)
+void clearpteu(pde_t *pgdir, char *uva)
 {
   pte_t *pte;
 
   pte = walkpgdir(pgdir, uva, 0);
-  if(pte == 0)
+  if (pte == 0)
     panic("clearpteu");
   *pte &= ~PTE_U;
 }
 
 // Given a parent process's page table, create a copy
 // of it for a child.
-pde_t*
+pde_t *
 copyuvm(pde_t *pgdir, uint sz)
 {
   pde_t *d;
@@ -320,19 +326,21 @@ copyuvm(pde_t *pgdir, uint sz)
   uint pa, i, flags;
   char *mem;
 
-  if((d = setupkvm()) == 0)
+  if ((d = setupkvm()) == 0)
     return 0;
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+  for (i = 0; i < sz; i += PGSIZE)
+  {
+    if ((pte = walkpgdir(pgdir, (void *)i, 0)) == 0)
       panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
+    if (!(*pte & PTE_P))
       panic("copyuvm: page not present");
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
+    if ((mem = kalloc()) == 0)
       goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+    memmove(mem, (char *)P2V(pa), PGSIZE);
+    if (mappages(d, (void *)i, PGSIZE, V2P(mem), flags) < 0)
+    {
       kfree(mem);
       goto bad;
     }
@@ -344,38 +352,38 @@ bad:
   return 0;
 }
 
-//PAGEBREAK!
-// Map user virtual address to kernel address.
-char*
+// PAGEBREAK!
+//  Map user virtual address to kernel address.
+char *
 uva2ka(pde_t *pgdir, char *uva)
 {
   pte_t *pte;
 
   pte = walkpgdir(pgdir, uva, 0);
-  if((*pte & PTE_P) == 0)
+  if ((*pte & PTE_P) == 0)
     return 0;
-  if((*pte & PTE_U) == 0)
+  if ((*pte & PTE_U) == 0)
     return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
+  return (char *)P2V(PTE_ADDR(*pte));
 }
 
 // Copy len bytes from p to user address va in page table pgdir.
 // Most useful when pgdir is not the current page table.
 // uva2ka ensures this only works for PTE_U pages.
-int
-copyout(pde_t *pgdir, uint va, void *p, uint len)
+int copyout(pde_t *pgdir, uint va, void *p, uint len)
 {
   char *buf, *pa0;
   uint n, va0;
 
-  buf = (char*)p;
-  while(len > 0){
+  buf = (char *)p;
+  while (len > 0)
+  {
     va0 = (uint)PGROUNDDOWN(va);
-    pa0 = uva2ka(pgdir, (char*)va0);
-    if(pa0 == 0)
+    pa0 = uva2ka(pgdir, (char *)va0);
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (va - va0);
-    if(n > len)
+    if (n > len)
       n = len;
     memmove(pa0 + (va - va0), buf, n);
     len -= n;
@@ -385,10 +393,33 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
   return 0;
 }
 
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
+// PAGEBREAK!
+//  Blank page.
+// PAGEBREAK!
+//  Blank page.
+// PAGEBREAK!
+//  Blank page.
 
+// 6.1 add vmprint defintion
+void vmprint(pde_t *pgdir)
+{
+  cprintf("pgdir %p\n", pgdir);
+
+  for (int i = 0; i < 512; i++) 
+    // PTE_P = present
+    if (pgdir[i] & PTE_P) { 
+      // PTE_ADDR = address
+      uint pa = PTE_ADDR(pgdir[i]); // obtain physical address
+      // SHOW PDE (page directory entry) physical address -> virtual address
+      cprintf(".. %d: pde 0x%x pa 0x%x\n", i, pa, P2V(pa));
+
+      // SHOW PTE (page table entry) physical address -> virtual address
+      pte_t* pt = (pte_t*)P2V(pa); 
+      for (int j = 0; j < 1024; j++) {
+          if (pt[j] & PTE_P) {
+              uint pte_pa = PTE_ADDR(pt[j]);
+              cprintf(".. .. %d: pte 0x%x pa 0x%x\n", j, PTE_ADDR(pt[j]), V2P(pte_pa));
+          }
+      }
+    }
+}
\ No newline at end of file
diff --git a/xv6.patch b/xv6.patch
new file mode 100644
index 00000000..671aacd2
--- /dev/null
+++ b/xv6.patch
@@ -0,0 +1,29 @@
+diff --git a/Makefile b/Makefile
+index 09d790c..3f4dbb7 100644
+--- a/Makefile
++++ b/Makefile
+@@ -76,7 +76,7 @@ AS = $(TOOLPREFIX)gas
+ LD = $(TOOLPREFIX)ld
+ OBJCOPY = $(TOOLPREFIX)objcopy
+ OBJDUMP = $(TOOLPREFIX)objdump
+-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
++CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -mno-sse -ggdb -m32 -fno-omit-frame-pointer
+ CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+ # FreeBSD ld wants ``elf_i386_fbsd''
+@@ -116,6 +116,7 @@ entryother: entryother.S
+ 
+ initcode: initcode.S
+ 	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
++	$(OBJCOPY) --remove-section .note.gnu.property initcode.o
+ 	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+ 	$(OBJCOPY) -S -O binary initcode.out initcode
+ 	$(OBJDUMP) -S initcode.o > initcode.asm
+@@ -146,6 +147,7 @@ vectors.S: vectors.pl
+ ULIB = ulib.o usys.o printf.o umalloc.o
+ 
+ _%: %.o $(ULIB)
++	$(OBJCOPY) --remove-section .note.gnu.property ulib.o
+ 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+ 	$(OBJDUMP) -S $@ > $*.asm
+ 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
